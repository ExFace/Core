<?php
namespace exface\Core\DataConnectors;

use exface\Core\CommonLogic\AbstractDataConnector;
use exface\Core\Exceptions\DataSources\DataConnectionFailedError;
use exface\Core\Exceptions\DataSources\DataConnectionCommitFailedError;
use exface\Core\Exceptions\DataSources\DataConnectionRollbackFailedError;
use exface\Core\CommonLogic\DataQueries\SqlDataQuery;
use exface\Core\Exceptions\DataSources\DataQueryFailedError;
use exface\Core\CommonLogic\Modelizers\OracleSqlModelizer;

/**
 * Datbase API object of OracleSQL
 *
 * @author Andrej Kabachnik
 *        
 */
class OracleSqlConnector extends AbstractSqlConnector
{

    private $insert_id_field_name = 'OID';

    private $last_insert_id = NULL;

    private $last_statement = NULL;

    private $sid = null;

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\CommonLogic\AbstractDataConnector::performConnect()
     */
    protected function performConnect()
    {
        $e = null;
        try {
            $conn = oci_connect($this->getUser(), $this->getPassword(), $this->getHost() . ':' . $this->getPort() . '/' . $this->getSid(), $this->getCharacterSet());
        } catch (\Throwable $e) {
            $conn = false;
        }
        
        if (! $conn) {
            throw new DataConnectionFailedError($this, 'Failed to create the database connection for "' . $this->getAliasWithNamespace() . '"!' . ($e ? ' ' . $e->getMessage() : ''), null, $e);
        } else {
            $this->setCurrentConnection($conn);
            // Set default date and time formats to ensure compatibility with ExFace
            $setup_query = new SqlDataQuery();
            $setup_query->setSql("ALTER SESSION SET NLS_TIMESTAMP_FORMAT = 'YYYY-MM-DD HH24:MI:SS' NLS_TIMESTAMP_TZ_FORMAT = 'YYYY-MM-DD HH24:MI:SS' NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS'");
            $this->performQuery($setup_query);
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\CommonLogic\AbstractDataConnector::performDisconnect()
     */
    protected function performDisconnect()
    {
        try {
            @ oci_close($this->getCurrentConnection());
        } catch (\Throwable $e) {
            // Do nothing if disconnect throws an error
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\CommonLogic\AbstractDataConnector::performQuery()
     *
     * @param SqlDataQuery $query            
     */
    protected function performQuerySql(SqlDataQuery $query)
    {
        $sql = $query->getSql();
        
        // If the statement is an insert, add a clause to save the autogenerated insert id
        if (substr($sql, 0, 6) == 'INSERT' && $this->insert_id_field_name) {
            $sql .= ' returning ' . $this->insert_id_field_name . ' into :id';
        }
        
        $e = null;
        try {
            $result = oci_parse($this->getCurrentConnection(), $sql);
        } catch (\Throwable $e) {
            $result = false;
        }
        
        if (! $result) {
            throw new DataQueryFailedError($query, "Pasrsing of a query to the database failed!" . ($e ? ' ' . $e->getMessage() : ''), '6T2T2UI', $e);
        } else {
            $this->last_statement = $result;
            // If the statement is an insert, bind the autogenerated id to the variabel $id
            $id = null;
            if (substr($sql, 0, 6) == 'INSERT') {
                OCIBindByName($result, ":ID", $id, 32);
            }
            
            $e = null;
            try {
                if ($this->getAutocommit()) {
                    $ex = @oci_execute($result);
                } else {
                    $ex = @oci_execute($result, OCI_NO_AUTO_COMMIT);
                }
            } catch (\Throwable $e) {
                $ex = false;
            }
            
            if (! $ex) {
                throw new DataQueryFailedError($query, "SQL query failed! " . ($this->getLastError() ? $this->getLastError() : ($e ? ' ' . $e->getMessage() : '')), '6T2T2UI', $e);
                return $query;
            } else {
                $query->setResultResource($result);
                return $query;
            }
        }
    }

    public function setInsertIdFieldName($value)
    {
        $this->insert_id_field_name = $value;
    }

    function getInsertId(SqlDataQuery $query)
    {
        return $this->last_insert_id;
    }

    function getAffectedRowsCount(SqlDataQuery $query)
    {
        try {
            return oci_num_rows($query->getResultResource());
        } catch (\Throwable $e) {
            throw new DataQueryFailedError($query, 'Failed to fetch the number of rows affected by the query: ' . $this->getLastError(), null, $e);
        }
    }

    function getLastError()
    {
        $error = oci_error($this->last_statement);
        return $error['message'];
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\DataConnectors\AbstractSqlConnector::makeArray()
     */
    public function makeArray(SqlDataQuery $query)
    {
        $rs = $query->getResultResource();
        if (! $rs)
            return array();
        $array = array();
        while ($row = @ oci_fetch_assoc($rs)) {
            $array[] = $row;
        }
        return $array;
    }

    /**
     *
     * {@inheritdoc} The OCI8 connector will start a transaction automatically with the first writing excecute()
     * @see \exface\Core\CommonLogic\AbstractDataConnector::transactionStart()
     */
    public function transactionStart()
    {
        // Make sure, the connection is established
        if (! $this->isConnected()) {
            $this->connect();
        }
        $this->setTransactionStarted(true);
        return $this;
    }

    public function transactionCommit()
    {
        // Do nothing if the autocommit option is set for this connection
        if ($this->getAutocommit()) {
            return $this;
        }
        
        if (! oci_commit($this->getCurrentConnection())) {
            throw new DataConnectionCommitFailedError($this, 'Cannot commit transaction in "' . $this->getAliasWithNamespace() . '": ' . $this->getLastError());
        }
        return $this;
    }

    public function transactionRollback()
    {
        // Throw error if trying to rollback a transaction with autocommit enabled
        if ($this->getAutocommit()) {
            throw new DataConnectionRollbackFailedError($this, 'Cannot rollback transaction in "' . $this->getAliasWithNamespace() . '": The autocommit options is set to TRUE for this connection!');
        }
        
        $e = null;
        try {
            $result = oci_rollback($this->getCurrentConnection());
        } catch (\Throwable $e) {
            $result = false;
        }
        
        if (! $result) {
            throw new DataConnectionRollbackFailedError($this, 'Cannot rollback transaction in "' . $this->getAliasWithNamespace() . '": ' . ($e ? $e->getMessage() : $this->getLastError()), null, $e);
        }
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\CommonLogic\AbstractDataConnector::transactionIsStarted()
     */
    public function transactionIsStarted()
    {
        return false;
    }

    public function freeResult(SqlDataQuery $query)
    {
        oci_free_statement($query->getResultResource());
    }

    /**
     *
     * @return string
     */
    public function getSid()
    {
        return $this->sid;
    }

    /**
     * Sets the sid to be used in this connection
     *
     * @uxon-property sid
     * @uxon-type string
     *
     * @param string $value            
     * @return OracleSqlConnector
     */
    public function setSid($value)
    {
        $this->sid = $value;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\DataConnectors\AbstractSqlConnector::exportUxonObject()
     */
    public function exportUxonObject()
    {
        $uxon = parent::exportUxonObject();
        $uxon->setProperty('sid', $this->getSid());
        return $uxon;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\DataConnectors\AbstractSqlConnector::getModelizer()
     */
    public function getModelizer()
    {
        return new OracleSqlModelizer($this);
    }
}
?>