<?php

namespace exface\Core\Behaviors;

use exface\Core\CommonLogic\DataSheets\DataSorter;
use exface\Core\CommonLogic\Debugger\LogBooks\BehaviorLogBook;
use exface\Core\CommonLogic\Model\Behaviors\AbstractBehavior;
use exface\Core\CommonLogic\Model\Behaviors\CustomAttributesDefinition;
use exface\Core\CommonLogic\Model\Behaviors\CustomAttributesLookup;
use exface\Core\CommonLogic\Model\CustomAttribute;
use exface\Core\CommonLogic\Model\RelationPath;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\DataTypes\RelationCardinalityDataType;
use exface\Core\Events\Behavior\OnBeforeBehaviorAppliedEvent;
use exface\Core\Events\Behavior\OnBehaviorAppliedEvent;
use exface\Core\Events\DataSheet\OnBeforeReadDataEvent;
use exface\Core\Events\DataSheet\OnReadDataEvent;
use exface\Core\Events\Model\OnMetaObjectLoadedEvent;
use exface\Core\Exceptions\Behaviors\BehaviorConfigurationError;
use exface\Core\Exceptions\Behaviors\BehaviorRuntimeError;
use exface\Core\Factories\ConditionFactory;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Factories\RelationPathFactory;
use exface\Core\Interfaces\DataSheets\DataSheetInterface;
use exface\Core\Interfaces\DataSources\SqlDataConnectorInterface;
use exface\Core\Interfaces\Model\BehaviorInterface;
use exface\Core\Interfaces\Model\MetaAttributeInterface;
use exface\Core\Interfaces\Model\MetaRelationInterface;
use exface\Core\Interfaces\Model\MetaRelationPathInterface;

/**
 * Adds read-only custom attributes to an object and fills them with values from a lookup data sheet.
 * 
 * ## Sorting and filtering
 * 
 * This behavior will read the values for its custom attributes separately and add them to the corresponding
 * columns of data sheets being read.
 * 
 * While reading the values is not a problem, filtering and sorting data over these attributes is a lot more
 * difficult. There are multiple options, you can choose from, which all have their ups and downs.
 * 
 *  - `filtering_method`
 *      - `none` - attributes, produced by this behavior will not be filterable
 *      - `custom_sql_join` - filter via autogenerated relations with custom SQL JOINs - see below.
 *  - `sorting_method`
 *       - `none` - attributes, produced by this behavior will not be sortable
 *       - `custom_sql_join` - sort via autogenerated relations with custom SQL JOINs - see below.
 * 
 * If no sorting/filtering method is defined, the workbench will attempt to choose the best one automatically.
 * 
 * ### Custom SQL JOINs
 * 
 * If sorting or filtering over attributes created by this behavior is requested, it will automatically
 * create invisible "fake" relations from the lookup object to the behavior object for every attribute, that is
 * being filtered or sorted. For example construction report example below, this would mean, that if we
 * are filtering over `REPORT_LOCATION` "Floor" to find reports for the 2nd floor, the behavior would create
 * a temporary relation attribute `REPORT_LOCATIONFloor` for the `REPORT` object with a custom `SQL_JOIN_ON`,
 * that will make sure to JOIN only floor-locations. This will allow filters to act just like each report would
 * have a direct relation to a floor. 
 * 
 * The filters and sorters are effectively replaced by similar ones using these fake relation: `Floor == 2` would
 * become `REPORT_LOCATIONFloor__Name == 2`.
 * 
 * This works well if each custom attribute can have at most one value for every object of the behavior. Of course,
 * this method requires all affected objects to be stored in the same SQL DB.
 * 
 * ## Examples
 * 
 * Consider construction reports that can be allocated to multiple locations: e.g. a report
 * is about a certain construction segment, which is part of a construction site, which is part
 * of a project, etc. All these locations are attributes of the report from the point of view
 * of the business. But if the construction hierarchy is dynamic, technically they will not
 * be stored as columns of the report table, but rather in a mapping table like `REPORT_LOCATION`.
 * Each report would have multiple entries in this table, each with a different location type.
 * 
 * The following behavior config will generate custom report attributes for every location type. 
 * For convenience, we put them all into the attribute group `my.App.LOCATIONS`, that we have created 
 * previously for the report object. This group will allow us to quickly place all location in table
 * `DataColumnGroup` or a `WidgetGroup`.
 *  
 * ```
 *  {
 *      "attributes_definition": {
 *          "object_alias": "my.App.LOCATION_TYPE"
 *      },
 *      "attribtues_defaults": {
 *          "groups": "my.App.LOCATIONS"
 *      },
 *      "values_lookup": {
 *          "object_alias": "my.App.REPORT_LOCATION",
 *          "relation_to_behavior_object": "REPORT_LOCATION__LOCATION",
 *          "values_content_column": "REPORT_LOCATION__REPORT",
 *          "values_attribute_alias_column": "LOCATION_TYPE__NAME"
 *      }
 *  }
 * 
 * ```
 * 
 * @author Andrej Kabachnik
 */
class CustomAttributesLookupBehavior extends AbstractBehavior
{
    const FILTERING_METHOD_CUSTOM_SQL_JOIN = 'custom_sql_join';
    const FILTERING_METHOD_NONE = 'none';
    
    const SORTING_METHOD_CUSTOM_SQL_JOIN = 'custom_sql_join';
    const SORTING_METHOD_NONE = 'none';
    
    private ?CustomAttributesDefinition $attributeDefinition = null;

    private ?CustomAttributesLookup $valuesLookup = null;

    private $attributes = null;
    private ?UxonObject $definitionDefaults = null;
    
    private ?string $filteringMethod = null;
    private ?string $sortingMethod = null;

    protected function registerEventListeners(): BehaviorInterface
    {
        $eventMgr = $this->getWorkbench()->eventManager();
        $eventMgr->addListener(
            OnMetaObjectLoadedEvent::getEventName(),
            [$this,'onLoadedAddAttributesToObject'],
            $this->getPriority()
        );
        $eventMgr->addListener(
            OnBeforeReadDataEvent::getEventName(),
            [$this,'onBeforeReadDataAddFiltersAndSorters'],
            $this->getPriority()
        );
        $eventMgr->addListener(
            OnReadDataEvent::getEventName(),
            [$this,'onReadDataJoinAttributes'],
            $this->getPriority()
        );

        return $this;
    }

    protected function unregisterEventListeners(): BehaviorInterface
    {
        $eventMgr = $this->getWorkbench()->eventManager();
        $eventMgr->removeListener(
            OnMetaObjectLoadedEvent::getEventName(),
            [$this,'onLoadedAddAttributesToObject']
        );
        $eventMgr->removeListener(
            OnBeforeReadDataEvent::getEventName(),
            [$this,'onBeforeReadDataAddFiltersAndSorters']
        );
        $eventMgr->removeListener(
            OnReadDataEvent::getEventName(),
            [$this,'onReadDataJoinAttributes']
        );

        return $this;
    }

    /**
     * Loads and adds temporary custom attributes from JSON definitions to the object this behavior is attached to.
     * 
     * @param OnMetaObjectLoadedEvent $event
     * @return void
     */
    public function onLoadedAddAttributesToObject(OnMetaObjectLoadedEvent $event) : void
    {
        if($this->isDisabled() || ! empty($this->attributes) || !$event->getObject()->isExactly($this->getObject())) {
            return;
        }

        $logBook = new BehaviorLogBook($this->getAlias(), $this, $event);
        $logBook->addLine('Object loaded, checking for custom attributes...');

        $this->getWorkbench()->eventManager()->dispatch(new OnBeforeBehaviorAppliedEvent($this, $event, $logBook));
        
        $definition = $this->getAttributesDefinition();
        $definitionBehavior = $definition->getDefinitionBehavior();
        $this->attributes = $definitionBehavior->addAttributesToObject($this->getObject(), $definition, $logBook);

        foreach ($this->attributes as $attr) {
            // This behavior definitely cannot produce attributes, that are writable, sortable or aggregatable,
            // so set the properties to false here regardless of attribute models or attribute defaults.
            $attr->setWritable(false);
            $attr->setFilterable($this->getFilteringMethod() !== self::FILTERING_METHOD_NONE);
            $attr->setSortable($this->getSortingMethod() !== self::SORTING_METHOD_NONE);
            $attr->setAggregatable(false);
        }

        $this->getWorkbench()->eventManager()->dispatch(new OnBehaviorAppliedEvent($this, $event, $logBook));
    }
    
    public function onBeforeReadDataAddFiltersAndSorters(OnBeforeReadDataEvent $event) : void
    {
        if($this->isDisabled()) {
            return;
        }

        $eventSheet = $event->getDataSheet();

        // Determine, if there are filters or sorters to be handled by this behavior
        $thisObj = $this->getObject();
        $affectedFilters = [];
        $affectedSorters = [];
        if ($this->getFilteringMethod() !== self::FILTERING_METHOD_NONE) {
            foreach ($eventSheet->getFilters()->getConditionsRecursive() as $cond) {
                if ($cond->isEmpty() === true || $cond->getExpression()->isMetaAttribute() === false) {
                    continue;
                }
                $attr = $cond->getExpression()->getAttribute();
                if ($attr->getObject()->isExactly($thisObj)) {
                    if (in_array($thisObj->getAttribute($attr->getAlias()), $this->attributes, true)) {
                        $affectedFilters[] = $cond;
                    }
                }
            }
        }
        if ($this->getSortingMethod() !== self::SORTING_METHOD_NONE) {
            foreach ($eventSheet->getSorters() as $sorter) {
                $attr = $eventSheet->getMetaObject()->getAttribute($sorter->getAttributeAlias());
                if ($attr->getObject()->isExactly($thisObj)) {
                    if (in_array($thisObj->getAttribute($attr->getAlias()), $this->attributes, true)) {
                        $affectedSorters[] = $sorter;
                    }
                }
            }
        }
        
        
        if (! empty($affectedFilters)) {
            $this->applyCustomSqlFilters($eventSheet, $affectedFilters);
        }

        if (! empty($affectedSorters)) {
            $this->applyCustomSqlSorters($eventSheet, $affectedSorters);
        }
    }

    /**
     * Replaces the given sorters with ones over matching fake relations with custom SQL JOINs
     * 
     * @param DataSheetInterface $dataSheet
     * @param array $sorters
     * @return DataSheetInterface
     */
    protected function applyCustomSqlSorters(DataSheetInterface $dataSheet, array $sorters) : DataSheetInterface
    {
        $lookup = $this->getValuesLookup();
        $customAttrValueCol = $lookup->getValuesContentColumnAlias();
        $relPathFromLookup = $lookup->getRelationPathToBehaviorObject();
        if ($relPathFromLookup->countRelations() > 1) {
            throw new BehaviorConfigurationError($this, 'Cannot use relation "' . $relPathFromLookup->toString() . '" with filtering/sorting method "custom_sql_join" - only direct relations allowed!');
        }
        $relFromLookup = $relPathFromLookup->getRelationFirst();
        $relPathToLookup = $relPathFromLookup->reverse();
        foreach ($sorters as $sorter) {
            $sorterAttr = $sorter->getAttribute();
            $fakeRel = $this->applyCustomSqlCreateFakeRelation($relPathToLookup, $relFromLookup, $sorterAttr);
            $sorterAttrAlias = RelationPath::join($fakeRel->getAlias(), $customAttrValueCol);
            if ($sorterAttr->isRelated()) {
                $sorterAttrAlias = RelationPath::join($sorterAttr->getRelationPath()->toString(), $sorterAttrAlias);
            }
            $sorterWithCustomJoin = new DataSorter($this->getWorkbench());
            $sorterWithCustomJoin->importUxonObject(
                new UxonObject([
                    'attribute_alias' => $sorterAttrAlias,
                    'direction' => $sorter->getDirection()
                ])
            );
            $dataSheet->getSorters()->remove($sorter)->add($sorterWithCustomJoin);
        }
        return $dataSheet;
    }

    /**
     * Replaces the given filter conditions with ones over matching fake relations with custom SQL JOINs
     * 
     * @param DataSheetInterface $dataSheet
     * @param array $conditions
     * 
     * @return DataSheetInterface
     */
    protected function applyCustomSqlFilters(DataSheetInterface $dataSheet, array $conditions) : DataSheetInterface
    {
        $lookup = $this->getValuesLookup();
        $customAttrValueCol = $lookup->getValuesContentColumnAlias();
        $relPathFromLookup = $lookup->getRelationPathToBehaviorObject();
        if ($relPathFromLookup->countRelations() > 1) {
            throw new BehaviorConfigurationError($this, 'Cannot use relation "' . $relPathFromLookup->toString() . '" with filtering/sorting method "custom_sql_join" - only direct relations allowed!');   
        }
        $relFromLookup = $relPathFromLookup->getRelationFirst();
        $relPathToLookup = $relPathFromLookup->reverse();
        $thisObj = $this->getObject();
        foreach ($conditions as $cond) {
            $condAttr = $cond->getExpression()->getAttribute();
            $fakeRel = $this->applyCustomSqlCreateFakeRelation($relPathToLookup, $relFromLookup, $condAttr);
            $filterAttrAlias = RelationPath::join($fakeRel->getAlias(), $customAttrValueCol);
            if ($condAttr->isRelated()) {
                $filterAttrAlias = RelationPath::join($condAttr->getRelationPath()->toString(), $filterAttrAlias);
            }
            $condWithCustomJoin = ConditionFactory::createFromUxon(
                $this->getWorkbench(),
                new UxonObject([
                    'object_alias' => $thisObj->getAliasWithNamespace(),
                    'expression' => $filterAttrAlias,
                    'comparator' => $cond->getComparator(),
                    'value' => $cond->getValue(),
                    'apply_to_aggregates' => false
                ]),
                $cond->willIgnoreEmptyValues()
            );
            $dataSheet->getFilters()->replaceCondition($cond, $condWithCustomJoin);
        }
        return $dataSheet;
    }
    
    protected function applyCustomSqlCreateFakeRelation(MetaRelationPathInterface $relPathToLookup, MetaRelationInterface $relFromLookup, MetaAttributeInterface $customAttr) : MetaRelationInterface
    {
        $thisObj = $this->getObject();
        $fakeRelAttr = new CustomAttribute($thisObj, $relPathToLookup->getEndObject(), $relPathToLookup->__toString() . $customAttr->getAlias());
        $fakeRelAttr->importUxonObject(new UxonObject([
            'hidden' => true,
            'relation' => [
                'related_object_alias' => $relPathToLookup->getEndObject()->getAliasWithNamespace(),
                'relation_cardinality' => RelationCardinalityDataType::ONE_TO_ONE
            ]
        ]));
        $thisObj->addAttribute($fakeRelAttr);
        $fakeRel = $fakeRelAttr->getRelation();
        $fakeRelAttr->setDataAddressProperties(new UxonObject([
            'SQL_JOIN_ON' => "[#~left:{$relFromLookup->getRightKeyAttribute()->getAlias()}#] = [#~right:{$relFromLookup->getLeftKeyAttribute()->getAlias()}#] 
                AND [#~right:{$this->getValuesLookup()->getValuesAttributeAliasColumnAlias()}#] = '{$customAttr->getAlias()}'"
        ]));
        return $fakeRel;
    }

    /**
     * Joins custom attribute values from a lookup data sheet to the data sheet of the object this behavior is attached to
     * 
     * @param \exface\Core\Events\DataSheet\OnReadDataEvent $event
     * @throws \exface\Core\Exceptions\Behaviors\BehaviorRuntimeError
     * @return void
     */
    public function onReadDataJoinAttributes(OnReadDataEvent $event) 
    {
        if($this->isDisabled()) {
            return;
        }

        $eventSheet = $event->getDataSheet();
        if ($eventSheet->isEmpty()) {
            return;
        }

        $thisObj = $this->getObject();
        $relPathToEventRequired = $eventSheet->getMetaObject()->isExactly($thisObj);
        $requiredAliases = [];
        $requiredRelationsPaths = [];
        if (! $relPathToEventRequired) {
            foreach ($eventSheet->getColumns()->getAll() as $col) {
                if ($col->isAttribute() && $col->getAttribute()->getObject()->isExactly($thisObj)) {
                    if (in_array($thisObj->getAttribute($col->getAttribute()->getAlias()), $this->attributes, true)) {
                        $requiredAliases[] = $col->getAttributeAlias();
                        $requiredRelationsPaths[] = $col->getAttribute()->getRelationPath()->__toString();
                    }
                }
            }
        } else {
            foreach ($eventSheet->getColumns() as $col) {
                if ($col->isAttribute() && in_array($col->getAttribute(), $this->attributes, true)) {
                    $requiredAliases[] = $col->getAttributeAlias();
                }
            }
        }
        if (empty($requiredAliases)) {
            return;
        }

        $logBook = new BehaviorLogBook($this->getAlias(), $this, $event);
        $logBook->addLine('Required lookup attributes: `' . implode(', ', $requiredAliases) . '`');
        $this->getWorkbench()->eventManager()->dispatch(new OnBeforeBehaviorAppliedEvent($this, $event, $logBook));

        $requiredRelationsPaths = array_unique($requiredRelationsPaths);
        if (count($requiredRelationsPaths) > 1) {
            throw new BehaviorRuntimeError($this,'Cannot read custom attribute values: multiple relations paths found for CustomAttributesLookupBehavior: `' . implode('`, `', $requiredRelationsPaths) . '`', null, null, $logBook);
        } elseif (count($requiredRelationsPaths) === 1) {
            $relPathEventToBehavior = RelationPathFactory::createFromString($eventSheet->getMetaObject(), $requiredRelationsPaths[0]);
            $relPathBehaviorToEvent = $relPathEventToBehavior->reverse();
        }
        
        $lookup = $this->getValuesLookup();
        // Create a lookup sheet. It needs a filter over the event objects and a column with their UIDs for the
        // JOIN later
        $lookupSheet = DataSheetFactory::createFromUxon($this->getWorkbench(), $lookup->getValuesDataSheetUxon() ?? new UxonObject(), $lookup->getObject());
        $eventSheetKeyAttr = $lookup->getRelationPathToBehaviorObject()->getRelationLast()->getRightKeyAttribute();
        $eventSheetKeyCol = $eventSheet->getColumns()->getByAttribute($eventSheetKeyAttr);
        if (! $eventSheetKeyCol) {
            throw new BehaviorRuntimeError($this, 'Cannot load custom attribute values: no key column ' . $eventSheetKeyAttr->__toString() . ' in event data!', null, null, $logBook);
        }
        $relPathLookupToBehavior = $lookup->getRelationPathToBehaviorObject();
        $relPathLookupToEvent = $relPathToEventRequired ? $relPathLookupToBehavior : $relPathLookupToBehavior->combine($relPathBehaviorToEvent);
        if ($relPathLookupToEvent->getRelationLast()->isReverseRelation()) {
            // Even if it is a reverse relations, it will always have one value per row as we
            // also filter over it!
            $relKeyLookupToEvent = RelationPath::join($relPathLookupToEvent->__toString(), $relPathLookupToEvent->getEndObject()->getUidAttributeAlias());
        } else {
            $relKeyLookupToEvent = $relPathLookupToEvent->__toString();
        }
        $lookupSheet->getFilters()->addConditionFromValueArray($relKeyLookupToEvent, $eventSheetKeyCol->getValues());
        $lookupKeyCol = $lookupSheet->getColumns()->addFromExpression($relKeyLookupToEvent);
        $lookupContentCol = $lookupSheet->getColumns()->addFromExpression($lookup->getValuesContentColumnAlias());
        $lookupContentName = $lookupContentCol->getName();
        $lookupAliasCol = $lookupSheet->getColumns()->addFromExpression($lookup->getValuesAttributeAliasColumnAlias());
        $lookupAliasName = $lookupAliasCol->getName();

        // Add more columns if required by the custom attribute definition
        $additionalCols = [];
        foreach ($lookup->getAdditionalColumns() as $lookupCol) {
            $additionalCols[] = $lookupSheet->getColumns()->addFromExpression($lookupCol->getLookupExpression(), null, true);
        }

        // Read lookup data
        $lookupSheet->dataRead();
        $logBook->addDataSheet('Custom attribute values', $lookupSheet);

        // Put the looked up values into the event data
        $delim = $lookupAliasCol->getAttribute()->getValueListDelimiter();
        foreach ($lookupSheet->getRows() as $row) {
            $key = $row[$lookupKeyCol->getName()];
            $eventRowIdx = $eventSheet->getUidColumn()->findRowByValue($key);
            if ($eventRowIdx === null) {
                continue;
            }
            $customAttrAlias = $row[$lookupAliasName];
            $val = $eventSheet->getCellValue($customAttrAlias, $eventRowIdx);
            $val .= ($val !== null ? $delim : '') . $row[$lookupContentName];
            if ($relPathToEventRequired) {
                $valEventColName = $customAttrAlias;
            } else {
                $valEventColName = RelationPath::join($relPathEventToBehavior->__toString(), $customAttrAlias);
            }
            $eventSheet->setCellValue($valEventColName, $eventRowIdx, $val);

            foreach ($additionalCols as $i => $additionalCol) {
                $lookupCol = $lookup->getAdditionalColumns()[$i];
                $addtionalColName = $lookupCol->getColumnName([
                    CustomAttributeDefinitionBehavior::PLACEHOLDER_ALIAS => $row[$lookupAliasName]
                ]);
                $eventSheet->setCellValue($addtionalColName, $eventRowIdx, $row[$additionalCol->getName()]);
            }
        }

        $this->getWorkbench()->eventManager()->dispatch(new OnBehaviorAppliedEvent($this, $event, $logBook));
    }

    /**
     * Where to find the corresponding CustomAttributeDefinitionBehavior
     * 
     * @uxon-property attributes_definition
     * @uxon-type \exface\Core\CommonLogic\Model\Behaviors\CustomAttributesDefinition
     * @uxon-required true
     * @uxon-template {"object_alias": ""}
     * 
     * @param \exface\Core\CommonLogic\UxonObject $uxon
     * @return CustomAttributesLookupBehavior
     */
    protected function setAttributesDefinition(UxonObject $uxon) : CustomAttributesLookupBehavior
    {
        if (null !== $objAlias = $uxon->getProperty('object_alias')) {
            if ($this->getObject()->isExactly($objAlias)) {
                throw new BehaviorConfigurationError($this, 'Cannot define CustomAttributesLookupBehavior for object ' . $this->getObject()->__toString() . ': the attributes_definition points to the same object - this will not work!');
            }
        }
        $this->attributeDefinition = new CustomAttributesDefinition($this, $uxon);
        if (null !== $defs = $this->getAttributesDefaults()) {
            $this->attributeDefinition->setAttributeDefaults($defs);
        }
        return $this;
    }

    /**
     * 
     * @return CustomAttributesDefinition|null
     */
    protected function getAttributesDefinition() : CustomAttributesDefinition
    {
        return $this->attributeDefinition;
    }

    /**
     * Change the default properties of attributes to be created
     * 
     * @uxon-property attributes_defaults
     * @uxon-type \exface\Core\CommonLogic\Model\Attribute
     * @uxon-template {"groups": [""], "value_list_delimiter": ","}
     * 
     * @param \exface\Core\CommonLogic\UxonObject $uxon
     * @return CustomAttributesLookupBehavior
     */
    protected function setAttributesDefaults(UxonObject $uxon) : CustomAttributesLookupBehavior
    {
        $this->definitionDefaults = $uxon;
        if ($this->attributeDefinition instanceof CustomAttributesDefinition) {
            $this->attributeDefinition->setAttributeDefaults($uxon);
        }
        return $this;
    }

    /**
     * 
     * @return UxonObject|null
     */
    protected function getAttributesDefaults() : UxonObject
    {
        return $this->definitionDefaults ?? new UxonObject([
            // TODO allow filtering for custom lookup attribtues somehow. For now, filterable is false by default.
            'filterable' => true,
            'value_list_delimiter' => EXF_LIST_SEPARATOR
        ]);
    }

    /**
     * Where to find values for the custom attributes
     * 
     * @uxon-property values_lookup
     * @uxon-type \exface\Core\CommonLogic\Model\Behaviors\CustomAttributesLookup
     * @uxon-required true
     * @uxon-template {"object_alias": "", "relation_to_behavior_object": "", "values_attribute_alias_column": "", "values_content_column": ""}
     * 
     * @param \exface\Core\CommonLogic\UxonObject $uxon
     * @return CustomAttributesLookupBehavior
     */
    protected function setValuesLookup(UxonObject $uxon) : CustomAttributesLookupBehavior
    {
        $this->valuesLookup = new CustomAttributesLookup($this, $uxon);
        return $this;
    }

    /**
     * 
     * @return CustomAttributesLookup
     */
    public function getValuesLookup() : CustomAttributesLookup
    {
        return $this->valuesLookup;
    }

    /**
     * Choose, how filtering over these custom attributes should work
     * 
     * @uxon-property filtering_method
     * @uxon-type [none,custom_sql_join]
     * @uxon-default none
     * 
     * @param string $method
     * @return $this
     */
    protected function setFilteringMethod(string $method) : CustomAttributesLookupBehavior
    {
        $this->filteringMethod = $method;
        return $this;
    }

    /**
     * @return string
     */
    protected function getFilteringMethod() : string
    {
        if ($this->filteringMethod === null) {
            switch (true) {
                case $this->sortingMethod === self::FILTERING_METHOD_CUSTOM_SQL_JOIN:
                case $this->isCustomSqlPossible():
                    $this->filteringMethod = self::FILTERING_METHOD_CUSTOM_SQL_JOIN;
                    break;
            }
        }
        return $this->filteringMethod ?? self::FILTERING_METHOD_NONE;
    }
    
    /**
     * Choose, how sorting over these custom attributes should work
     *
     * @uxon-property sorting_method
     * @uxon-type [none,custom_sql_join]
     * @uxon-default none
     *
     * @param string $method
     * @return $this
     */
    protected function setSortingMethod(string $method) : CustomAttributesLookupBehavior
    {
        $this->sortingMethod = $method;
        return $this;
    }

    /**
     * @return string
     */
    protected function getSortingMethod() : string
    {
        if ($this->sortingMethod === null) {
            switch (true) {
                case $this->filteringMethod === self::FILTERING_METHOD_CUSTOM_SQL_JOIN:
                case $this->isCustomSqlPossible():
                    $this->sortingMethod = self::SORTING_METHOD_CUSTOM_SQL_JOIN;
                    break;
            }
        }
        return $this->sortingMethod ?? self::SORTING_METHOD_NONE;
    }

    /**
     * Returns TRUE if custom SQL JOINs are possible for this behavior
     * 
     * @return bool
     */
    protected function isCustomSqlPossible() : bool
    {
        if ($this->getObject()->isReadable() && $this->getObject()->getDataSource()->getConnection() instanceof SqlDataConnectorInterface) {
            $lookup = $this->getValuesLookup();
            $relPathToBehavior = $lookup->getRelationPathToBehaviorObject();
            if ($relPathToBehavior->countRelations() > 1) {
                return false;
            }
            if (! $relPathToBehavior->getRelationFirst()->isForwardRelation()) {
                return false;
            }
            $objConnection = $this->getObject()->getDataSource()->getConnection();
            $lookupConnection = $lookup->getObject()->getDataSource()->getConnection();
            if (! $lookupConnection instanceof SqlDataConnectorInterface) {
                return false;
            }
            if (! $lookupConnection->canJoin($objConnection)) {
                return false;
            }
            return true;
        }
        return false;
    }
}