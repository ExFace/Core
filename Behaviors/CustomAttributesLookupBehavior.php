<?php

namespace exface\Core\Behaviors;

use exface\Core\CommonLogic\DataSheets\DataAggregation;
use exface\Core\CommonLogic\DataSheets\DataSorter;
use exface\Core\CommonLogic\Debugger\LogBooks\BehaviorLogBook;
use exface\Core\CommonLogic\Model\Behaviors\AbstractBehavior;
use exface\Core\CommonLogic\Model\Behaviors\CustomAttributesDefinition;
use exface\Core\CommonLogic\Model\Behaviors\CustomAttributesLookup;
use exface\Core\CommonLogic\Model\CustomAttribute;
use exface\Core\CommonLogic\Model\RelationPath;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\DataTypes\RelationCardinalityDataType;
use exface\Core\Events\Behavior\OnBeforeBehaviorAppliedEvent;
use exface\Core\Events\Behavior\OnBehaviorAppliedEvent;
use exface\Core\Events\DataSheet\OnBeforeReadDataEvent;
use exface\Core\Events\DataSheet\OnReadDataEvent;
use exface\Core\Events\Model\OnMetaObjectLoadedEvent;
use exface\Core\Exceptions\Behaviors\BehaviorConfigurationError;
use exface\Core\Exceptions\Behaviors\BehaviorRuntimeError;
use exface\Core\Factories\ConditionFactory;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Factories\RelationPathFactory;
use exface\Core\Interfaces\DataSheets\DataSheetInterface;
use exface\Core\Interfaces\DataSources\SqlDataConnectorInterface;
use exface\Core\Interfaces\Model\BehaviorInterface;
use exface\Core\Interfaces\Model\MetaAttributeInterface;
use exface\Core\Interfaces\Model\MetaRelationInterface;
use exface\Core\Interfaces\Model\MetaRelationPathInterface;

/**
 * Adds read-only custom attributes to an object and fills them with values from a lookup data sheet.
 * 
 * ## Reading, sorting and filtering
 * 
 * This behavior supports multiple methods of working with values of the custom attributes. It will try to determine
 * the best method automatically, but you can override it in the configuration of the behavior. In the following
 * subsections the different methods are explained in detail. 
 * 
 *  - `reading_method`
 *      - `separate_reads` - lookup values are read separately at `OnDataRead` event
 *  - `filtering_method`
 *      - `none` - attributes produced by this behavior will not be filterable
 *      - `custom_sql_join` - filter via autogenerated relations with custom SQL JOINs - see below.
 *  - `sorting_method`
 *       - `none` - attributes produced by this behavior will not be sortable
 *       - `custom_sql_join` - sort via autogenerated relations with custom SQL JOINs - see below.
 * 
 * ### Separate reads
 * 
 * This is the most universal method - it should always work, but does not support filtering and sorting. It is
 * also probably the slowest one. The behavior will read the values for its custom attributes separately every
 * time its object is read and add them to the corresponding columns of data sheets.
 * 
 * Custom attribute values, that are not among the columns of the data sheet will not be read.
 * 
 * ### Custom SQL JOINs
 *
 * This method uses SQL to filter/sort over custom attributes. It works well if each custom attribute can have at 
 * most one value for every object of the behavior. Of course, this method requires all affected objects to be 
 * stored in the same SQL DB.
 * 
 * If sorting or filtering over attributes created by this behavior is requested, it will automatically
 * create invisible "fake" relations from the lookup object to the behavior object for every attribute, that is
 * being filtered or sorted. For the construction report example below, this would mean, that if we
 * are filtering over `REPORT_LOCATION` "Floor" to find reports for the 2nd floor, the behavior would create
 * a temporary relation attribute `REPORT_LOCATIONFloor` for the `REPORT` object with a custom `SQL_JOIN_ON`,
 * that will make sure to JOIN only floor-locations. This will allow filters to act just like each report would
 * have a direct relation to a floor. 
 * 
 * The filters and sorters are effectively replaced by similar ones using these fake relation: `Floor == 2` would
 * become `REPORT_LOCATIONFloor__Name == 2`.
 * 
 * ## Examples
 * 
 * ### Allocation of construction reports
 * 
 * Consider construction reports that can be allocated to multiple locations: e.g. a report
 * is about two rooms on a certain floor, which is part of a construction site, which is part
 * of a project, etc. Each room, every floor, the site and even the project are "locations" kept
 * in a hierarchy in master data.
 * 
 * However, from the business point of view, affected rooms, floors, etc. are attributes of the report. 
 * But if the construction hierarchy is dynamic, technically they will not be stored as columns of the 
 * report table, but rather in a mapping table like `REPORT_LOCATION`. Each report would have multiple 
 * entries in this table, each with a different location type.
 * 
 * The following behavior config will generate custom report attributes for every location type. 
 * For convenience, we put them all into the attribute group `my.App.LOCATIONS`, that we have created 
 * previously for the report object. This group will allow us to quickly place all location in table
 * `DataColumnGroup` or a `WidgetGroup`.
 *  
 * ```
 *  {
 *      "attributes_definition": {
 *          "object_alias": "my.App.LOCATION_TYPE"
 *      },
 *      "attribtues_defaults": {
 *          "groups": "my.App.LOCATIONS"
 *      },
 *      "values_lookup": {
 *          "object_alias": "my.App.REPORT_LOCATION",
 *          "relation_to_behavior_object": "REPORT_LOCATION__LOCATION",
 *          "values_content_column": "REPORT_LOCATION__REPORT",
 *          "values_attribute_alias_column": "LOCATION_TYPE__NAME",
 *          "multiple_values_expected": true,
 *          "multiple_values_delimiter": ", "
 *          "multiple_values_aggregator": "LIST_DISTINCT"
 *      }
 *  }
 * 
 * ```
 * 
 * ### Precalculated KPIs
 * 
 * Another example would be calculating KPI for important business objects like projects. If the KPIs are
 * stored in a separate object (e.g. an SQL view), we would expect a data row for every KPI and every
 * business object (project). Again, having Attributes for every KPI directly on the business object is
 * much more comfortable.
 * 
 * In contrast to the locations in the example above, we are expecting exactly one KPI value per project,
 * so the lookup logic is a little simpler here.
 *
 * ```
 *   {
 *       "attributes_definition": {
 *           "object_alias": "my.App.KPI_DEFINITION"
 *       },
 *       "attribtues_defaults": {
 *           "groups": "my.App.KPIs"
 *       },
 *       "values_lookup": {
 *           "object_alias": "my.App.PROJECT_KPIS",
 *           "relation_to_behavior_object": "PROJECT",
 *           "values_content_column": "VALUE",
 *           "values_attribute_alias_column": "KPI_DEFINITION__ALIAS",
 *           "multiple_values_expected": false 
 *       }
 *   }
 * 
 * ```
 * 
 * @author Andrej Kabachnik
 */
class CustomAttributesLookupBehavior extends AbstractBehavior
{
    const FILTERING_METHOD_CUSTOM_SQL_JOIN = 'custom_sql_join';
    const FILTERING_METHOD_NONE = 'none';
    
    const SORTING_METHOD_CUSTOM_SQL_JOIN = 'custom_sql_join';
    const SORTING_METHOD_NONE = 'none';
    
    private ?CustomAttributesDefinition $attributeDefinition = null;

    private ?CustomAttributesLookup $valuesLookup = null;

    private $attributes = null;
    private ?UxonObject $definitionDefaults = null;
    
    private ?string $filteringMethod = null;
    private ?string $sortingMethod = null;

    protected function registerEventListeners(): BehaviorInterface
    {
        $eventMgr = $this->getWorkbench()->eventManager();
        $eventMgr->addListener(
            OnMetaObjectLoadedEvent::getEventName(),
            [$this,'onLoadedAddAttributesToObject'],
            $this->getPriority()
        );
        $eventMgr->addListener(
            OnBeforeReadDataEvent::getEventName(),
            [$this,'onBeforeReadDataAddFiltersAndSorters'],
            $this->getPriority()
        );
        $eventMgr->addListener(
            OnReadDataEvent::getEventName(),
            [$this,'onReadDataJoinAttributes'],
            $this->getPriority()
        );

        return $this;
    }

    protected function unregisterEventListeners(): BehaviorInterface
    {
        $eventMgr = $this->getWorkbench()->eventManager();
        $eventMgr->removeListener(
            OnMetaObjectLoadedEvent::getEventName(),
            [$this,'onLoadedAddAttributesToObject']
        );
        $eventMgr->removeListener(
            OnBeforeReadDataEvent::getEventName(),
            [$this,'onBeforeReadDataAddFiltersAndSorters']
        );
        $eventMgr->removeListener(
            OnReadDataEvent::getEventName(),
            [$this,'onReadDataJoinAttributes']
        );

        return $this;
    }

    /**
     * Loads and adds temporary custom attributes from JSON definitions to the object this behavior is attached to.
     * 
     * @param OnMetaObjectLoadedEvent $event
     * @return void
     */
    public function onLoadedAddAttributesToObject(OnMetaObjectLoadedEvent $event) : void
    {
        if($this->isDisabled() || ! empty($this->attributes) || !$event->getObject()->isExactly($this->getObject())) {
            return;
        }

        $logBook = new BehaviorLogBook($this->getAlias(), $this, $event);
        $logBook->addLine('Object loaded, checking for custom attributes...');

        $this->getWorkbench()->eventManager()->dispatch(new OnBeforeBehaviorAppliedEvent($this, $event, $logBook));
        
        $definition = $this->getAttributesDefinition();
        $definitionBehavior = $definition->getDefinitionBehavior();
        $this->attributes = $definitionBehavior->addAttributesToObject($this->getObject(), $definition, $logBook);
        $lookup = $this->getValuesLookup();
        $listDelim = $lookup->getMultipleValuesDelimiter() ?? EXF_LIST_SEPARATOR;

        foreach ($this->attributes as $attr) {
            // This behavior definitely cannot produce attributes, that are writable, sortable or aggregatable,
            // so set the properties to false here regardless of attribute models or attribute defaults.
            $attr->setWritable(false);
            $attr->setAggregatable(false);
            $attr->setFilterable($this->supportsFiltering());
            $attr->setSortable($this->supportsSorting());
            if ($lookup->isMultipleValuesExpected()) {
                $attr->setValueListDelimiter($listDelim);
            }
        }

        $this->getWorkbench()->eventManager()->dispatch(new OnBehaviorAppliedEvent($this, $event, $logBook));
    }
    
    public function onBeforeReadDataAddFiltersAndSorters(OnBeforeReadDataEvent $event) : void
    {
        if($this->isDisabled()) {
            return;
        }

        $eventSheet = $event->getDataSheet();

        // Determine, if there are filters or sorters to be handled by this behavior
        $thisObj = $this->getObject();
        $affectedFilters = [];
        $affectedSorters = [];
        if ($this->supportsFiltering()) {
            foreach ($eventSheet->getFilters()->getConditionsRecursive() as $cond) {
                if ($cond->isEmpty() === true || $cond->getExpression()->isMetaAttribute() === false) {
                    continue;
                }
                $attr = $cond->getExpression()->getAttribute();
                if ($attr->getObject()->isExactly($thisObj)) {
                    if (in_array($thisObj->getAttribute($attr->getAlias()), $this->attributes, true)) {
                        $affectedFilters[] = $cond;
                    }
                }
            }
        }
        if ($this->supportsSorting()) {
            foreach ($eventSheet->getSorters() as $sorter) {
                $attr = $eventSheet->getMetaObject()->getAttribute($sorter->getAttributeAlias());
                if ($attr->getObject()->isExactly($thisObj)) {
                    if (in_array($thisObj->getAttribute($attr->getAlias()), $this->attributes, true)) {
                        $affectedSorters[] = $sorter;
                    }
                }
            }
        }
        
        
        if (! empty($affectedFilters)) {
            $this->applyCustomSqlFilters($eventSheet, $affectedFilters);
        }

        if (! empty($affectedSorters)) {
            $this->applyCustomSqlSorters($eventSheet, $affectedSorters);
        }
    }

    /**
     * Replaces the given sorters with ones over matching fake relations with custom SQL JOINs
     * 
     * @param DataSheetInterface $dataSheet
     * @param array $sorters
     * @return DataSheetInterface
     */
    protected function applyCustomSqlSorters(DataSheetInterface $dataSheet, array $sorters) : DataSheetInterface
    {
        $lookup = $this->getValuesLookup();
        $customAttrValueCol = $lookup->getValuesContentColumnAlias();
        $relPathFromLookup = $lookup->getRelationPathToBehaviorObject();
        if ($relPathFromLookup->countRelations() > 1) {
            throw new BehaviorConfigurationError($this, 'Cannot use relation "' . $relPathFromLookup->toString() . '" with filtering/sorting method "custom_sql_join" - only direct relations allowed!');
        }
        $relFromLookup = $relPathFromLookup->getRelationFirst();
        $relPathToLookup = $relPathFromLookup->reverse();
        foreach ($sorters as $sorter) {
            $sorterAttr = $sorter->getAttribute();
            $fakeRel = $this->applyCustomSqlCreateFakeRelation($relPathToLookup, $relFromLookup, $sorterAttr);
            $sorterAttrAlias = RelationPath::join($fakeRel->getAlias(), $customAttrValueCol);
            if ($sorterAttr->isRelated()) {
                $sorterAttrAlias = RelationPath::join($sorterAttr->getRelationPath()->toString(), $sorterAttrAlias);
            }
            if ($lookup->isMultipleValuesExpected() === true) {
                $sorterAttrAlias = DataAggregation::addAggregatorToAlias($sorterAttrAlias, $lookup->getMultipleValuesAggregator());
            }
            
            $sorterWithCustomJoin = new DataSorter($this->getWorkbench());
            $sorterWithCustomJoin->importUxonObject(
                new UxonObject([
                    'attribute_alias' => $sorterAttrAlias,
                    'direction' => $sorter->getDirection()
                ])
            );
            $dataSheet->getSorters()->remove($sorter)->add($sorterWithCustomJoin);
        }
        return $dataSheet;
    }

    /**
     * Replaces the given filter conditions with ones over matching fake relations with custom SQL JOINs
     * 
     * @param DataSheetInterface $dataSheet
     * @param array $conditions
     * 
     * @return DataSheetInterface
     */
    protected function applyCustomSqlFilters(DataSheetInterface $dataSheet, array $conditions) : DataSheetInterface
    {
        $lookup = $this->getValuesLookup();
        $customAttrValueCol = $lookup->getValuesContentColumnAlias();
        $relPathFromLookup = $lookup->getRelationPathToBehaviorObject();
        if ($relPathFromLookup->countRelations() > 1) {
            throw new BehaviorConfigurationError($this, 'Cannot use relation "' . $relPathFromLookup->toString() . '" with filtering/sorting method "custom_sql_join" - only direct relations allowed!');   
        }
        $relFromLookup = $relPathFromLookup->getRelationFirst();
        $relPathToLookup = $relPathFromLookup->reverse();
        $thisObj = $this->getObject();
        foreach ($conditions as $cond) {
            $condAttr = $cond->getExpression()->getAttribute();
            $fakeRel = $this->applyCustomSqlCreateFakeRelation($relPathToLookup, $relFromLookup, $condAttr);
            $filterAttrAlias = RelationPath::join($fakeRel->getAlias(), $customAttrValueCol);
            if ($condAttr->isRelated()) {
                $filterAttrAlias = RelationPath::join($condAttr->getRelationPath()->toString(), $filterAttrAlias);
            }
            /** FIXME add aggregator to filter as soon as LIST and LIST_DISTINCT are fixed for MS SQL
            if ($lookup->isMultipleValuesExpected() === true) {
                $filterAttrAlias = DataAggregation::addAggregatorToAlias($filterAttrAlias, $lookup->getMultipleValuesAggregator());
            }*/
            
            $condWithCustomJoin = ConditionFactory::createFromUxon(
                $this->getWorkbench(),
                new UxonObject([
                    'object_alias' => $thisObj->getAliasWithNamespace(),
                    'expression' => $filterAttrAlias,
                    'comparator' => $cond->getComparator(),
                    'value' => $cond->getValue(),
                    'apply_to_aggregates' => false
                ]),
                $cond->willIgnoreEmptyValues()
            );
            $dataSheet->getFilters()->replaceCondition($cond, $condWithCustomJoin);
        }
        return $dataSheet;
    }
    
    protected function applyCustomSqlCreateFakeRelation(MetaRelationPathInterface $relPathToLookup, MetaRelationInterface $relFromLookup, MetaAttributeInterface $customAttr) : MetaRelationInterface
    {
        $thisObj = $this->getObject();
        $fakeRelAttr = new CustomAttribute($thisObj, $relPathToLookup->getEndObject(), $relPathToLookup->__toString() . $customAttr->getAlias());
        $lookupAliasExpr = $this->getValuesLookup()->getValuesAttributeAliasColumnExpression();
        $onlyOneAttribute = $lookupAliasExpr->isConstant();
        if (! $lookupAliasExpr->isMetaAttribute() && ! $onlyOneAttribute) {
            throw new BehaviorConfigurationError($this, 'Cannot use custom SQL sorting/filtering if the values_attribute_alias_column is not an attribute alias');
        }
        $fakeRelUxon = new UxonObject([
            'hidden' => true,
            'relation' => [
                'related_object_alias' => $relPathToLookup->getEndObject()->getAliasWithNamespace(),
                'related_object_key_attribute_alias' => $relPathToLookup->getRelationLast()->getRightKeyAttribute()->getId(),
                'relation_cardinality' => $this->getValuesLookup()->isMultipleValuesExpected() ? RelationCardinalityDataType::ONE_TO_N : RelationCardinalityDataType::ONE_TO_ONE
            ]
        ]);
        $fakeRelAttr->importUxonObject($fakeRelUxon);
        $thisObj->addAttribute($fakeRelAttr);
        $fakeRel = $fakeRelAttr->getRelation();
        if ($onlyOneAttribute) {
            $fakeRelAttr->setDataAddressProperties(new UxonObject([
                'SQL_JOIN_ON' => "[#~left:{$relFromLookup->getRightKeyAttribute()->getAlias()}#] = [#~right:{$relFromLookup->getLeftKeyAttribute()->getAlias()}#]"
            ]));
        } else {
            $fakeRelAttr->setDataAddressProperties(new UxonObject([
                'SQL_JOIN_ON' => "[#~left:{$relFromLookup->getRightKeyAttribute()->getAlias()}#] = [#~right:{$relFromLookup->getLeftKeyAttribute()->getAlias()}#] 
                    AND [#~right:{$lookupAliasExpr->getAttributeAlias()}#] = '{$customAttr->getAlias()}'"
            ]));
        }
        return $fakeRel;
    }

    /**
     * Joins custom attribute values from a lookup data sheet to the data sheet of the object this behavior is attached to
     * 
     * @param \exface\Core\Events\DataSheet\OnReadDataEvent $event
     * @throws \exface\Core\Exceptions\Behaviors\BehaviorRuntimeError
     * @return void
     */
    public function onReadDataJoinAttributes(OnReadDataEvent $event) 
    {
        if($this->isDisabled()) {
            return;
        }

        $eventSheet = $event->getDataSheet();
        if ($eventSheet->isEmpty()) {
            return;
        }

        $thisObj = $this->getObject();
        $relPathToEventRequired = $eventSheet->getMetaObject()->isExactly($thisObj);
        $requiredAliases = [];
        $requiredRelationsPaths = [];
        if (! $relPathToEventRequired) {
            foreach ($eventSheet->getColumns()->getAll() as $col) {
                if ($col->isAttribute() && $col->getAttribute()->getObject()->isExactly($thisObj)) {
                    if (in_array($thisObj->getAttribute($col->getAttribute()->getAlias()), $this->attributes, true)) {
                        $requiredAliases[] = $col->getAttributeAlias();
                        $requiredRelationsPaths[] = $col->getAttribute()->getRelationPath()->__toString();
                    }
                }
            }
        } else {
            foreach ($eventSheet->getColumns() as $col) {
                if ($col->isAttribute() && in_array($col->getAttribute(), $this->attributes, true)) {
                    $requiredAliases[] = $col->getAttributeAlias();
                }
            }
        }
        if (empty($requiredAliases)) {
            return;
        }

        $logBook = new BehaviorLogBook($this->getAlias(), $this, $event);
        $logBook->addLine('Required lookup attributes: `' . implode(', ', $requiredAliases) . '`');
        $this->getWorkbench()->eventManager()->dispatch(new OnBeforeBehaviorAppliedEvent($this, $event, $logBook));

        $requiredRelationsPaths = array_unique($requiredRelationsPaths);
        if (count($requiredRelationsPaths) > 1) {
            throw new BehaviorRuntimeError($this,'Cannot read custom attribute values: multiple relations paths found for CustomAttributesLookupBehavior: `' . implode('`, `', $requiredRelationsPaths) . '`', null, null, $logBook);
        } elseif (count($requiredRelationsPaths) === 1) {
            $relPathEventToBehavior = RelationPathFactory::createFromString($eventSheet->getMetaObject(), $requiredRelationsPaths[0]);
            $relPathBehaviorToEvent = $relPathEventToBehavior->reverse();
        }
        
        $lookup = $this->getValuesLookup();
        // Create a lookup sheet. It needs a filter over the event objects and a column with their UIDs for the
        // JOIN later
        $lookupSheet = DataSheetFactory::createFromUxon($this->getWorkbench(), $lookup->getValuesDataSheetUxon() ?? new UxonObject(), $lookup->getObject());
        $eventSheetKeyAttr = $lookup->getRelationPathToBehaviorObject()->getRelationLast()->getRightKeyAttribute();
        $eventSheetKeyCol = $eventSheet->getColumns()->getByAttribute($eventSheetKeyAttr);
        if (! $eventSheetKeyCol) {
            throw new BehaviorRuntimeError($this, 'Cannot load custom attribute values: no key column ' . $eventSheetKeyAttr->__toString() . ' in event data!', null, null, $logBook);
        }
        $relPathLookupToBehavior = $lookup->getRelationPathToBehaviorObject();
        $relPathLookupToEvent = $relPathToEventRequired ? $relPathLookupToBehavior : $relPathLookupToBehavior->combine($relPathBehaviorToEvent);
        if ($relPathLookupToEvent->getRelationLast()->isReverseRelation()) {
            // Even if it is a reverse relations, it will always have one value per row as we
            // also filter over it!
            $relKeyLookupToEvent = RelationPath::join($relPathLookupToEvent->__toString(), $relPathLookupToEvent->getEndObject()->getUidAttributeAlias());
        } else {
            $relKeyLookupToEvent = $relPathLookupToEvent->__toString();
        }
        $lookupSheet->getFilters()->addConditionFromValueArray($relKeyLookupToEvent, $eventSheetKeyCol->getValues());
        $lookupKeyCol = $lookupSheet->getColumns()->addFromExpression($relKeyLookupToEvent);
        $lookupContentCol = $lookupSheet->getColumns()->addFromExpression($lookup->getValuesContentColumnAlias());
        $lookupContentName = $lookupContentCol->getName();
        $lookupAliasCol = $lookupSheet->getColumns()->addFromExpression($lookup->getValuesAttributeAliasColumnExpression());
        $lookupAliasName = $lookupAliasCol->getName();

        // Add more columns if required by the custom attribute definition
        $additionalCols = [];
        foreach ($lookup->getAdditionalColumns() as $lookupCol) {
            $additionalCols[] = $lookupSheet->getColumns()->addFromExpression($lookupCol->getLookupExpression(), null, true);
        }
        
        if (null !== $lookupMapper = $this->getValuesLookup()->getValuesInputMapper()) {
            $lookupSheet = $lookupMapper->map($eventSheet, null, $logBook, $lookupSheet);
        }

        // Read lookup data
        $lookupSheet->dataRead();
        $logBook->addDataSheet('Custom attribute values', $lookupSheet);

        // Put the looked up values into the event data
        $delim = $lookupAliasCol->getValueListDelimiter();
        foreach ($lookupSheet->getRows() as $row) {
            $key = $row[$lookupKeyCol->getName()];
            $eventRowIdx = $eventSheet->getUidColumn()->findRowByValue($key);
            if ($eventRowIdx === null) {
                continue;
            }
            $customAttrAlias = $row[$lookupAliasName];
            if ($customAttrAlias === null) {
                throw new BehaviorRuntimeError($this, 'Cannot lookup custom attribute values for ' . $thisObj->__toString() . '. Empty values detected in `' . $lookupAliasName . '` column of ' . $lookupSheet->getMetaObject()->__toString() . ', but these values are required by the CustomAttributesLookupBehavior as `values_attribute_alias_column`!');
            }
            $val = $eventSheet->getCellValue($customAttrAlias, $eventRowIdx);
            $val .= ($val !== null ? $delim : '') . $row[$lookupContentName];
            if ($relPathToEventRequired) {
                $valEventColName = $customAttrAlias;
            } else {
                $valEventColName = RelationPath::join($relPathEventToBehavior->__toString(), $customAttrAlias);
            }
            $eventSheet->setCellValue($valEventColName, $eventRowIdx, $val);

            foreach ($additionalCols as $i => $additionalCol) {
                $lookupCol = $lookup->getAdditionalColumns()[$i];
                $addtionalColName = $lookupCol->getColumnName([
                    CustomAttributeDefinitionBehavior::PLACEHOLDER_ALIAS => $row[$lookupAliasName]
                ]);
                $eventSheet->setCellValue($addtionalColName, $eventRowIdx, $row[$additionalCol->getName()]);
            }
        }

        $this->getWorkbench()->eventManager()->dispatch(new OnBehaviorAppliedEvent($this, $event, $logBook));
    }

    /**
     * Where to find the corresponding CustomAttributeDefinitionBehavior
     * 
     * @uxon-property attributes_definition
     * @uxon-type \exface\Core\CommonLogic\Model\Behaviors\CustomAttributesDefinition
     * @uxon-required true
     * @uxon-template {"object_alias": ""}
     * 
     * @param \exface\Core\CommonLogic\UxonObject $uxon
     * @return CustomAttributesLookupBehavior
     */
    protected function setAttributesDefinition(UxonObject $uxon) : CustomAttributesLookupBehavior
    {
        if (null !== $objAlias = $uxon->getProperty('object_alias')) {
            if ($this->getObject()->isExactly($objAlias)) {
                throw new BehaviorConfigurationError($this, 'Cannot define CustomAttributesLookupBehavior for object ' . $this->getObject()->__toString() . ': the attributes_definition points to the same object - this will not work!');
            }
        }
        $this->attributeDefinition = new CustomAttributesDefinition($this, $uxon);
        if (null !== $defs = $this->getAttributesDefaults()) {
            $this->attributeDefinition->setAttributeDefaults($defs);
        }
        return $this;
    }

    /**
     * 
     * @return CustomAttributesDefinition|null
     */
    protected function getAttributesDefinition() : CustomAttributesDefinition
    {
        return $this->attributeDefinition;
    }

    /**
     * Change the default properties of attributes to be created
     * 
     * @uxon-property attributes_defaults
     * @uxon-type \exface\Core\CommonLogic\Model\Attribute
     * @uxon-template {"groups": [""]}
     * 
     * @param \exface\Core\CommonLogic\UxonObject $uxon
     * @return CustomAttributesLookupBehavior
     */
    protected function setAttributesDefaults(UxonObject $uxon) : CustomAttributesLookupBehavior
    {
        $this->definitionDefaults = $uxon;
        if ($this->attributeDefinition instanceof CustomAttributesDefinition) {
            $this->attributeDefinition->setAttributeDefaults($uxon);
        }
        return $this;
    }

    /**
     * 
     * @return UxonObject|null
     */
    protected function getAttributesDefaults() : UxonObject
    {
        // No defaults here - they will all be set later dynamically in onLoadedAddAttributesToObject()
        return $this->definitionDefaults ?? new UxonObject();
    }

    /**
     * Where to find values for the custom attributes
     * 
     * @uxon-property values_lookup
     * @uxon-type \exface\Core\CommonLogic\Model\Behaviors\CustomAttributesLookup
     * @uxon-required true
     * @uxon-template {"object_alias": "", "relation_to_behavior_object": "", "values_attribute_alias_column": "", "values_content_column": ""}
     * 
     * @param \exface\Core\CommonLogic\UxonObject $uxon
     * @return CustomAttributesLookupBehavior
     */
    protected function setValuesLookup(UxonObject $uxon) : CustomAttributesLookupBehavior
    {
        $this->valuesLookup = new CustomAttributesLookup($this, $uxon);
        return $this;
    }

    /**
     * 
     * @return CustomAttributesLookup
     */
    public function getValuesLookup() : CustomAttributesLookup
    {
        return $this->valuesLookup;
    }

    /**
     * Choose, how filtering over these custom attributes should work
     * 
     * @uxon-property filtering_method
     * @uxon-type [none,custom_sql_join]
     * @uxon-default none
     * 
     * @param string $method
     * @return $this
     */
    protected function setFilteringMethod(string $method) : CustomAttributesLookupBehavior
    {
        $this->filteringMethod = $method;
        return $this;
    }

    /**
     * @return string
     */
    protected function getFilteringMethod() : string
    {
        if ($this->filteringMethod === null) {
            switch (true) {
                case $this->sortingMethod === self::SORTING_METHOD_CUSTOM_SQL_JOIN:
                case $this->isCustomSqlPossible():
                    $this->filteringMethod = self::FILTERING_METHOD_CUSTOM_SQL_JOIN;
                    break;
            }
        }
        return $this->filteringMethod ?? self::FILTERING_METHOD_NONE;
    }

    /**
     * @return bool
     */
    protected function supportsFiltering() : bool
    {
        return $this->getFilteringMethod() !== self::FILTERING_METHOD_NONE;
    }
    
    /**
     * Choose, how sorting over these custom attributes should work
     *
     * @uxon-property sorting_method
     * @uxon-type [none,custom_sql_join]
     * @uxon-default none
     *
     * @param string $method
     * @return $this
     */
    protected function setSortingMethod(string $method) : CustomAttributesLookupBehavior
    {
        $this->sortingMethod = $method;
        return $this;
    }

    /**
     * @return string
     */
    protected function getSortingMethod() : string
    {
        if ($this->sortingMethod === null) {
            switch (true) {
                case $this->filteringMethod === self::FILTERING_METHOD_CUSTOM_SQL_JOIN:
                case $this->isCustomSqlPossible():
                    $this->sortingMethod = self::SORTING_METHOD_CUSTOM_SQL_JOIN;
                    break;
            }
        }
        return $this->sortingMethod ?? self::SORTING_METHOD_NONE;
    }

    /**
     * @return bool
     */
    protected function supportsSorting() : bool
    {
        return $this->getSortingMethod() !== self::SORTING_METHOD_NONE;
    }

    /**
     * Returns TRUE if custom SQL JOINs are possible for this behavior
     * 
     * @return bool
     */
    protected function isCustomSqlPossible() : bool
    {
        if ($this->getObject()->isReadable() && $this->getObject()->getDataSource()->getConnection() instanceof SqlDataConnectorInterface) {
            $lookup = $this->getValuesLookup();
            $relPathToBehavior = $lookup->getRelationPathToBehaviorObject();
            if ($relPathToBehavior->countRelations() > 1) {
                return false;
            }
            if (! $relPathToBehavior->getRelationFirst()->isForwardRelation()) {
                return false;
            }
            $objConnection = $this->getObject()->getDataSource()->getConnection();
            $lookupConnection = $lookup->getObject()->getDataSource()->getConnection();
            if (! $lookupConnection instanceof SqlDataConnectorInterface) {
                return false;
            }
            if (! $lookupConnection->canJoin($objConnection)) {
                return false;
            }
            return true;
        }
        return false;
    }
}