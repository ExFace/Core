<?php
namespace exface\Core\Interfaces;

use exface\Core\Interfaces\DataSheets\DataSheetInterface;
use exface\Core\Interfaces\Model\MetaObjectInterface;
use exface\Core\CommonLogic\WidgetDimension;
use exface\Core\Exceptions\Widgets\WidgetConfigurationError;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\Interfaces\Model\MetaRelationPathInterface;
use exface\Core\Interfaces\Model\UiPageInterface;
use exface\Core\Interfaces\Widgets\iHaveCaption;
use exface\Core\Interfaces\Widgets\iHaveVisibility;
use exface\Core\Interfaces\Facades\FacadeInterface;

/**
 * 
 * @author Andrej Kabachnik
 *
 */
interface WidgetInterface extends WorkbenchDependantInterface, iCanBeCopied, iCanBeConvertedToUxon, iHaveCaption, iHaveVisibility, iCanGenerateDebugWidgets
{
    /**
     * Prefills the widget with values of a data sheet.
     * 
     * Each widget has it's own prefill logic: simple value widgets will just look for
     * a suitable cell value in the data sheet, key-value widgets will try to get
     * both, while complex data widgets may use filters, rows, UIDs, etc.
     * 
     * The prefill process produces three types of events: `OnBeforePrefill` and
     * `OnPrefill` will be fired for every widget, the prefill data is passed to - before 
     * and after processing it - regardless of whether it affetcs a widget or not.
     * `OnPrefillChangeProperty`, on the other hand, will be fired only if the prefill
     * actually affects the widget and will be triggered for every widget property
     * that is changed. This event let's you examine the results of the prefill
     * in detail as it contains old and new values of the affected properties.
     *
     * @triggers \exface\Core\Events\Widget\OnBeforePrefillEvent
     * @triggers \exface\Core\Events\Widget\OnPrefillEvent
     * @triggers \exface\Core\Events\Widget\OnPrefillChangePropertyEvent
     *
     * @param \exface\Core\Interfaces\DataSheets\DataSheetInterface $data_sheet            
     * @return void
     */
    public function prefill(DataSheetInterface $data_sheet);
    
    /**
     * Returns TRUE if this widget can be prefilled and FALSE otherwise.
     * 
     * @return boolean
     */
    public function isPrefillable();
    
    /**
     * Returns TRUE if the widget was prefilled and FALSE otherwise.
     * 
     * @return bool
     */
    public function isPrefilled() : bool;

    /**
     * Adds attributes, filters, etc.
     * to a given data sheet, so that it can be used to fill the widget with data
     *
     * @param DataSheetInterface $data_sheet            
     * @return DataSheetInterface
     */
    public function prepareDataSheetToRead(DataSheetInterface $data_sheet = null);

    /**
     * Adds attributes, filters, etc.
     * to a given data sheet, so that it can be used to prefill the widget
     *
     * @param DataSheetInterface $data_sheet            
     * @return DataSheetInterface
     */
    public function prepareDataSheetToPrefill(DataSheetInterface $data_sheet = null) : DataSheetInterface;

    /**
     * Returns the widget id provided in the UXON or NULL if no id was specified.
     * 
     * @see getId() for the final widget id
     * 
     * NOTE: by default, the widget id will include the id space prefix. If you really
     * need just the value found in the UXON, set $includeIdSpace to FALSE!
     *
     * @param bool $includeIdSpace
     * @return string|NULL
     */
    public function getIdSpecified(bool $includeIdSpace = true) : ?string;

    /**
     * Returns the widget id generated automatically for this widget or NULL if an 
     * id was specified explicitly.
     * 
     * @see getId() for the final widget id
     * @see getIdSpecified() for the id specified in the UXON
     * 
     * @return string|NULL
     */
    public function getIdAutogenerated() : ?string;

    /**
     * Sets the autogenerated id for this widget
     *
     * @param string $value            
     * @return \exface\Core\Interfaces\WidgetInterface
     */
    public function setIdAutogenerated($value);

    /**
     * Specifies the id of the widget explicitly, overriding any previos values.
     * The given id must be unique
     * within the page. It will not be modified automatically in any way.
     *
     * @param string $value            
     * @return WidgetInterface
     */
    public function setId($value);

    /**
     * Retruns the id space of this widget.
     * 
     * @see getIdSpace() for details.
     *
     * @return string
     */
    public function getIdSpace();

    /**
     * Sets the id space for this widget, so that it's explicitly specified id only needs to 
     * be unique inside the id space and not among all widgets of the page.
     * 
     * NOTE: user-specified ids get automatically prefixed with the id space of the widget!
     * Autogenerated ids do not (they are unique in any case)!
     * 
     * Using id spaces is important for explicitly specified ids, which are used in
     * widget links. Since pages can consist of many different UXON snippets, each might have
     * it's own custom ids inside. There is no way to check if they are unique in advance! In
     * other words, the user, that types an id cannot know, if it is going to cause conflicts. 
     * Using an id space makes sure, the custom id only needs to be unique within the id space
     * and not globally on the page.
     *
     * In particular, id spaces allow to reuse complex widgets with live references and other links 
     * multiple times on a single page. A complex oject editor, for example, can be used by the create,
     * update and dublicate buttons on one page. To make the links within the editor work, each
     * button must have it's own id space.
     * 
     * Id spaces are sometimes added automatically - e.g. the ShowDialog action uses a separate
     * id space for it's dialogs.
     *
     * @param string $value            
     * @return WidgetInterface
     */
    public function setIdSpace($value);

    /**
     *
     * @throws WidgetConfigurationError
     * @return \exface\Core\Interfaces\Model\MetaObjectInterface
     */
    public function getMetaObject();

    /**
     * Returns an array with all objects, that will have significant effect on this widget.
     * 
     * It is important for a widget to know, changes to which affect its inner state - e.g. make
     * its prefill data obsolete. Facades should then decide, what to do - e.g. refresh the widget,
     * show a warning, etc.
     * 
     * This feature goes hand-in-hand with action effects - see ActionInterface::getEffects(). An
     * action knows, which objects it will effect and a widget knows, if these objects will effect
     * its current state.
     * 
     * This method will only return objects, that have "significant" effects, requiring some
     * reaction. For example, if a container has children with lazy loading, their object should
     * not be in this list because these widget will be able to take care of their changes
     * themselves - their contents is not the business of the container.
     * 
     * @see \exface\Core\Interfaces\Actions\ActionEffectInterface
     * @see \exface\Core\Interfaces\Actions\ActionInterface::getEffects()
     * @see \exface\Core\Interfaces\Actions\ActionInterface::hasEffectOn()
     * @see \exface\Core\Interfaces\Actions\ActionInterface::getEffectsOn()
     * 
     * @return MetaObjectInterface[]
     */
    public function getMetaObjectsEffectingThisWidget() : array;

    /**
     * Sets the given object as the new base object for this widget
     *
     * @param MetaObjectInterface $object            
     */
    public function setMetaObject(MetaObjectInterface $object);

    /**
     * Returns the id of this widget or NULL if there is no id yet (= widget is not part of a page).
     * 
     * @see getIdSpecified() for the id set for the widget explicitly
     * @see getIdAutogenerated() for the id generated by the page automatically
     * 
     * @param bool $includeNamespace
     * @return string|NULL
     */
    public function getId(bool $includeNamespace = true) : ?string;

    /**
     * Returns the widget type (e.g.
     * DataTable)
     *
     * @return string
     */
    public function getWidgetType();

    /**
     * Returns TRUE/FALSE if the widget was disabled/enabled explicitly anf NULL otherwise.
     * 
     * @return bool|NULL
     */
    public function isDisabled() : ?bool;

    /**
     *
     * @param bool|NULL $value
     * @param string|NULL $reason 
     * @return WidgetInterface           
     */
    public function setDisabled(?bool $trueOrFalseOrNull, string $reason = null) : WidgetInterface;

    /**
     * Returns a dimension object representing the height of the widget.
     *
     * @return WidgetDimension
     */
    public function getWidth();

    /**
     * Sets the width of the widget.
     * The width may be specified in relative ExFace units (in this case, the value is numeric)
     * or in any unit compatible with the current facade (in this case, the value is alphanumeric because the unit must be
     * specified directltly).
     *
     * @param WidgetDimension|string $value            
     * @return WidgetInterface
     */
    public function setWidth($value);

    /**
     * Returns a dimension object representing the height of the widget.
     *
     * @return WidgetDimension
     */
    public function getHeight();

    /**
     * Sets the height of the widget.
     * The height may be specified in relative ExFace units (in this case, the value is numeric)
     * or in any unit compatible with the current facade (in this case, the value is alphanumeric because the unit must be
     * specified directltly).
     *
     * @param WidgetDimension|string|NULL $value            
     * @return WidgetInterface
     */
    public function setHeight($value);

    /**
     *
     * @param string $qualified_alias_with_namespace            
     */
    public function setObjectAlias($qualified_alias_with_namespace);

    /**
     * Returns the relation path from the object of the parent widget to the object of this widget.
     * 
     * If both widgets are based on the same object or no valid path can be found, 
     * an empty path will be returned.
     *
     * @return MetaRelationPathInterface
     */
    public function getObjectRelationPathFromParent() : ?MetaRelationPathInterface;

    /**
     * Returns the relation path from the object of this widget to the object of its parent widget.
     * 
     * Returns an empty relation path if both widgets are based on the same object
     * Returns NULL if no valid path can be found.
     *
     * @return MetaRelationPathInterface|NULL
     */
    public function getObjectRelationPathToParent() : ?MetaRelationPathInterface;

    /**
     *
     * @param string $string            
     */
    public function setObjectRelationPathToParent($string);

    /**
     * Returns TRUE if the meta object of this widget was not set explicitly but inherited from it's parent and FALSE otherwise.
     *
     * @return bool
     */
    public function isObjectInheritedFromParent() : bool;

    /**
     * Returns the parent widget
     *
     * @return WidgetInterface|null
     */
    public function getParent();
    
    /**
     * Returns TRUE if the widget has a parent and FALSE if it is a root widget.
     * 
     * @return boolean
     */
    public function hasParent();

    /**
     * Sets the parent widget
     *
     * @param WidgetInterface $widget            
     */
    public function setParent(WidgetInterface $widget);

    /**
     * 
     * @param bool $includeDebugInfo
     * @return string|NULL
     */
    public function getHint(bool $includeDebugInfo = true) : ?string;

    /**
     *
     * @param string $value            
     */
    public function setHint($value);

    /**
     *
     * @return boolean
     */
    public function isHidden();

    /**
     *
     * @param boolean $value            
     */
    public function setHidden($value);

    /**
     * Returns the data sheet used to prefill the widget or null if the widget is not prefilled
     *
     * @return DataSheetInterface
     */
    public function getPrefillData();

    /**
     *
     * @param DataSheetInterface $data_sheet            
     */
    public function setPrefillData(DataSheetInterface $data_sheet);

    /**
     * Checks if the widget implements the given interface (e.g.
     * "iHaveButtons"), etc.
     *
     * @param string $interface_name            
     */
    public function implementsInterface($interface_name);

    /**
     * Returns TRUE if the widget is of the given widget type or extends from it and FALSE otherwise
     * (e.g.
     * a DataTable would return TRUE for DataTable and Data)
     *
     * @param string $widget_type            
     * @return boolean
     *
     * @see is_exactly()
     */
    public function is($widget_type);

    /**
     * Returns TRUE if the widget is of the given type and FALSE otherwise.
     * In contrast to is(), it will return FALSE even
     * if the widget extends from the given type.
     *
     * @param string $widget_type            
     * @return boolean
     *
     * @see is()
     */
    public function isExactly($widget_type);

    /**
     * Explicitly tells the widget to use the given data connection to fetch data (instead of the one specified on the base
     * object's data source)
     *
     * @param string $value            
     */
    public function setDataConnectionAlias($value);

    /**
     *
     * @return UiPageInterface
     */
    public function getPage();

    /**
     * Returns the orignal UXON description of this widget specified by the user, that is without any automatic enhancements
     *
     * @return \exface\Core\CommonLogic\UxonObject|\exface\Core\CommonLogic\UxonObject
     */
    public function exportUxonObjectOriginal();
    
    /**
     * Returns TRUE if prefilling is explicitly disabled for this widget and FALSE otherwise (default).
     *
     * @return boolean
     */
    public function getDoNotPrefill();
    
    /**
     * Disable prefilling this widget with input or prefill data, making it allways have the value defined in UXON.
     * 
     * @uxon-property do_not_prefill
     * @uxon-type boolean
     * 
     * @param boolean $true_or_false
     * @return WidgetInterface
     */
    public function setDoNotPrefill($true_or_false);
    
    /**
     * Returns an iterator over all direct children of the current widget.
     *
     * @return WidgetInterface[]
     */
    public function getChildren() : \Iterator;
    
    /**
     * Returns an iterator over all children of the current widget including with their children,
     * childrens children, etc. as a flat array of widgets
     * 
     * If provided, depth limits the number of recursion levels.
     *
     * @param int|NULL $depth
     * 
     * @return WidgetInterface[]
     */
    public function getChildrenRecursive(?int $depth = null) : \Iterator;
    
    /**
     * Returns true if current widget has at least one child and FALSE otherwise.
     *
     * @return bool
     */
    public function hasChildren() : bool;
    
    /**
     * 
     * @param FacadeInterface $facade
     * @return UxonObject|NULL
     */
    public function getFacadeOptions(FacadeInterface $facade) : ?UxonObject;
    
    /**
     * 
     * @param FacadeInterface $facade
     * @return bool
     */
    public function hasFacadeOptions(FacadeInterface $facade) : bool;

    /**
     * Checks if the given meta object has a relation to the object of this widget and returns
     * the corresponding relation path or NULL if no relation can be found.
     * 
     * If the two objects match, an empty relation path will be returned.
     * 
     * @param MetaObjectInterface $object
     * @return MetaRelationPathInterface|NULL
     */
    public function findRelationPathFromObject(MetaObjectInterface $object) : ?MetaRelationPathInterface;
    
    /**
     * 
     * @param string $functionName
     * @return bool
     */
    public function hasFunction(string $functionName) : bool;
}