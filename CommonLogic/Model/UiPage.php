<?php
namespace exface\Core\CommonLogic\Model;

use exface\Core\Interfaces\Model\UiPageInterface;
use exface\Core\Interfaces\WidgetInterface;
use exface\Core\Interfaces\Facades\FacadeInterface;
use exface\Core\Factories\WidgetFactory;
use exface\Core\Exceptions\Widgets\WidgetIdConflictError;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Exceptions\Widgets\WidgetNotFoundError;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\Exceptions\InvalidArgumentException;
use exface\Core\Factories\UiPageFactory;
use exface\Core\CommonLogic\Traits\ImportUxonObjectTrait;
use exface\Core\DataTypes\BooleanDataType;
use exface\Core\DataTypes\NumberDataType;
use exface\Core\Exceptions\UiPage\UiPageNotFoundError;
use exface\Core\Interfaces\Selectors\AliasSelectorInterface;
use exface\Core\Interfaces\Selectors\UiPageSelectorInterface;
use exface\Core\Factories\SelectorFactory;
use exface\Core\Interfaces\Selectors\AppSelectorInterface;
use exface\Core\Events\Widget\OnRemoveEvent;
use exface\Core\Factories\FacadeFactory;
use exface\Core\Exceptions\LogicException;
use exface\Core\Exceptions\RuntimeException;
use exface\Core\Interfaces\DataSheets\DataSheetInterface;
use exface\Core\Interfaces\Model\UiMenuItemInterface;
use exface\Core\CommonLogic\Traits\UiMenuItemTrait;
use exface\Core\Factories\UserFactory;
use exface\Core\Events\Widget\OnUiPageInitializedEvent;
use exface\Core\Interfaces\Selectors\PWASelectorInterface;
use exface\Core\CommonLogic\Selectors\PWASelector;
use exface\Core\CommonLogic\Translation\UxonTranslator;
use exface\Core\Interfaces\Widgets\iHaveIcon;

/**
 * This is the default implementation of the UiPageInterface.
 * 
 * The first widget without a parent added to the page is concidered to be the
 * main root widget.
 * 
 * Widgets get cached in an internal array.
 * 
 * @see UiPageInterface
 * 
 * @author Andrej Kabachnik
 *
 */
class UiPage implements UiPageInterface, iHaveIcon
{
    use ImportUxonObjectTrait;
    
    use UiMenuItemTrait;

    const WIDGET_ID_SEPARATOR = '_';

    const WIDGET_ID_SPACE_SEPARATOR = '.';

    private $widgets = array();

    private $facadeSelector = null;
    
    private $facadeUxon = null;
    
    private $facade = null;
    
    private $selector = null;

    private $widget_root = null;

    private $context_bar = null;

    private $updateable = true;

    private $menuParentPageSelector = null;
    
    private $menuParentPageSelectorDefault = null;
    
    private $menuIndex = null;

    private $menuIndexDefault = null;
    
    private $menuVisible = true;
    
    private $menuHome = false;

    private $id = null;

    private $name = '';
    
    private $description = '';

    private $intro = '';

    private $replacesPageSelector = null;

    private $contents = null;

    private $contents_uxon = null;

    private $aliasWithNamespace = null;
    
    private $pwaSelector = null;

    private $dirty = false;

    /**
     * @deprecated use UiPageFactory::create() instead!
     * 
     * @param UiPageSelectorInterface $selector
     */
    public function __construct(UiPageSelectorInterface $selector)
    {
        $this->selector = $selector;
    }

    /**
     *
     * @param WidgetInterface $widget            
     * @throws WidgetIdConflictError
     * @return \exface\Core\CommonLogic\Model\UiPage
     */
    public function addWidget(WidgetInterface $widget)
    {
        $id = $widget->getId();
        if ($id === null) {
            $uniqueId = $this->generateWidgetId($widget);
            $widget->setIdAutogenerated($uniqueId);
        } else {
            $uniqueId = $this->makeWidgetIdUnique($id);
        }
        if ($widget->getIdSpecified() !== null && ($this->widgets[$widget->getIdSpecified()] ?? null) !== null) {
            throw new WidgetIdConflictError($widget, 'Explicitly specified id "' . $widget->getIdSpecified() . '" for widget "' . $widget->getWidgetType() . '" not unique on page "' . $this->getUid() . '": please specify a unique id for the widget in the UXON description of the page!');
        }
        
        // Remember the first widget added automatically as the root widget of the page
        if (empty($this->widgets) && ! $widget->is('ContextBar')) {
            $this->widget_root = $widget;
        }
        
        $this->widgets[$widget->getId()] = $widget;
        
        return $this;
    }

    /**
     *
     * @return \exface\Core\Interfaces\WidgetInterface
     */
    public function getWidgetRoot()
    {
        if ($this->isDirty()) {
            $this->regenerateFromContents();
        }
        return $this->widget_root;
    }

    /**
     * Initializes all widgets from the contents of the page
     * 
     * @return UiPage
     */
    protected function regenerateFromContents()
    {
        $this->removeAllWidgets();
        if (! $this->getContentsUxon()->isEmpty()) {
            WidgetFactory::createFromUxon($this, $this->getContentsUxon());
        }
        $this->dirty = false;
        $this->getWorkbench()->eventManager()->dispatch(new OnUiPageInitializedEvent($this));
        return $this;
    }

    /**
     * Returns the UXON representation of the contents (or an empty UXON object if there is no contents
     * or the contents is not UXON).
     * 
     * NOTE: This method will return an empty UXON object even if the page has some other type of contents
     * (e.g. HTML). Do not use this method to get the contents in general, use getContents() instead. This
     * method is only legitim if you know, the page has UXON content.
     * 
     * @return UxonObject
     */
    public function getContentsUxon()
    {
        if (is_null($this->contents_uxon)) {
            if (! is_null($this->contents)) {
                $contents = $this->getContents();
                if (substr($contents, 0, 1) == '{' && substr($contents, - 1) == '}') {
                    $uxon = UxonObject::fromAnything($contents);
                    if ($this->hasApp()) {
                        (new UxonTranslator($this->getApp()->getTranslator()))->translateUxonProperties($uxon, 'Pages/' . $this->getAliasWithNamespace(), 'CONTENT');
                    }
                } else {
                    $uxon = new UxonObject();
                }
            } else {
                $uxon = new UxonObject();
            }
        } else {
            $uxon = $this->contents_uxon;
        }
        
        return $uxon;
    }

    /**
     *
     * {@inheritdoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getWidget()
     */
    public function getWidget($id, WidgetInterface $parent = null)
    {
        if ($this->isDirty()) {
            $this->regenerateFromContents();
        }
        
        if (is_null($id) || $id == '') {
            return $this->getWidgetRoot();
        }
        
        // First check to see, if the widget id is already in the widget list. If so, return the corresponding widget.
        // Otherwise look throgh the entire tree to make sure, even subwidgets with late binding can be found (= that is
        // those, that are created if a certain property of another widget is accessed.
        if ($widget = $this->widgets[$id]) {
            // FIXME Check if one of the ancestors of the widget really is the given parent. Although this should always
            // be the case, but better doublecheck ist.
            return $widget;
        }
        
        // If the parent is null, look under the root widget
        // FIXME this makes a non-parent lookup in pages with multiple roots impossible.
        if (is_null($parent)) {
            if (StringDataType::startsWith($id . static::WIDGET_ID_SEPARATOR, $this->getContextBar()->getId()) || StringDataType::startsWith($id . static::WIDGET_ID_SPACE_SEPARATOR, $this->getContextBar()->getId())) {
                $parent = $this->getContextBar();
            } else {
                // If the page is empty, no widget can be found ;) ...except the widget, that are always there
                if ($this->isEmpty()) {
                    throw new WidgetNotFoundError('Widget "' . $id . '" not found in page "' . $this->getAliasWithNamespace() . '": page empty!');
                }
                $parent = $this->getWidgetRoot();
            }
        }
        
        // If the widget id contains an id space, first attempt to determine the parent
        // widget of that id space. This is possible if the id space is the id of the
        // spaces parent widget (e.g. an id space produced by ShowWidget-actions). Searching
        // only inside the parent significantly reduces the number of widgets to examine.
        $id_original = $id;
        $id_space = '';
        $parent_of_id_space = $parent;
        while ($id_space_length = strpos($id, static::WIDGET_ID_SPACE_SEPARATOR)) {
            $id_space = ($id_space ? $id_space . static::WIDGET_ID_SPACE_SEPARATOR : '' ) . substr($id, 0, $id_space_length);
            $id = substr($id, $id_space_length + 1);
            $parent_of_id_space = $this->getWidgetFromIdSpace($id_space, '', $parent_of_id_space);
        }
        
        return $this->getWidgetFromIdSpace($id_original, '', $parent_of_id_space);
    }

    /**
     * This method contains the searching algorithm for finding a widget in a parent by it's id.
     * 
     * One of the main goals is to decrease the number of widgets, that need to be instantiated
     * by including the parent id in the child id, thus creating id-paths. The trouble is though,
     * that user-defined ids can be hidden anywhere in the widget tree, so we can't assume, that
     * all ids adhere to the path-idea. Another challange is the search for widgets, that where
     * repositioned after receiving the id (thus, the id does not match the path anymore).
     * 
     * By default, the algorithm will try to determine, if the given id is a path. If so, it will
     * only search within widgets along that path (only these widgets will get instantiated). Only
     * for non-path ids or in the case, where a path-like id cannot be found, a full search of the
     * tree will be performed.
     * 
     * Here is a typical page with a data table as an example. The ids are shortened to two letters
     * and a number, so DT is a DataTable, TC is DataTableConfigurator, BT is a button, etc. Our
     * Table has a configurator, one toolbar (DT_TB) with a single button group with 3 buttons and
     * one column group (DT_CG) with 4 columns. The second button and the third colum have user-
     * defined ids. All other ids are autogenerated.
     * 
     * DT - DT_TC - DT_TC_TA - DT_TC_TA_FI  - DT_TC_TA_FI_IN
     *   |                  +- DT_TC_TA_FI2 - DT_TC_CA_FI2_CT
     *   |
     *   +- DT_TB - DT_TB_BG  - DT_TB_BG_BT
     *   |       |           +- mybtn ------ - mybtn_DI ------ - mybtn_DI_IN
     *   |       |           |                                +- mybtn_DI_IN2
     *   |       |           |                                +- mybtn_DI_IN3
     *   |       |           |
     *   |       |           +- DT_TB_BG_BT2 - DT_TB_BG_BT2_DI - DT_TB_BG_BT2_DT - DT_TB_BG_BT2_DT_CO
     *   |       |                                                              +- DT_TB_BG_BT2_DT_CO2
     *   |       |                                                              +- DT_TB_BG_BT2_DT_CO3
     *   |       +- DT_TB_BG2 - DT_BT_BG2_BT
     *   |                   +- DT_BT_BG_BT3
     *   |       
     *   |                              
     *   |
     *   +- DT_CG - DT_CG_CO
     *           +- DT_CG_CO2
     *           +- mycol
     *           +- DT_CG_CO3
     *           
     * Here are some examples, of how the searching works:
     * 
     * (1) Searching for the Filter-InputComboTable with id DT_TC_CA_FI2_CT. The id will get identified as
     * a path because it starts with DT, which is the id of the root widget. Iterating over the children
     * of DT will immediately yield a path-match on DT_TC. The search continues there and so on until
     * a full match is found.
     * 
     * (2) Searching for the button DT_TB_BG_BT works similarly, but DT_TC does not fit the path, so
     * the search among the children of DT continues without traversing up the DT_TC-branch.
     * 
     * (3) Searching for mybtn results in searching the DT_TC-branch completely and the beginning of
     * the DT_TB-branch.
     * 
     * (4) The DataTable within the Dialog DT_TB_BG_BT2_DI was moved there after being instantiated
     * for the button DT_TB_BG_BT2 directly, so it has the id DT_TB_BG_BT2_TB instead of one with
     * a full path (DT_TB_BG_BT2_DI_TB). The path-search will work upto the button and will result
     * in a miss while iterating over the button's children. In this case, a fallback search through
     * all widgets in the DT_TB_BG_BT2-branch is initiated, which will lead to the desired result.
     * The same happens if a button is instantiated programmatically with the DT as parent and is
     * getting moved to the default button group of the default toolbar when being added to the table.
     * 
     * (5) In the worst case, widgets can get moved somewhere far away (outside of their paren) like 
     * button DT_BT_BG_BT3 which was created in the first button group, but was moved to the second one 
     * for some reason. This happens really rarely though.
     *  
     * IDEA Buttons showing widgets will currently load their widget and treat it as a child even if
     * it is linked from another page and not defined explicity. Perhaps, we can optimize here a little
     * and make iShowWidget::getWidget() only return widgets from the current page, while offering
     * a second way to get the widget via iShowWidget::getWidgetLink()->...
     * 
     * @param string $id
     * @param string $id_space
     * @param WidgetInterface $parent
     * @param boolean $use_id_path
     * 
     * @throws WidgetNotFoundError if no matching widget was found
     * 
     * @return WidgetInterface
     */
    private function getWidgetFromIdSpace($id, $id_space, WidgetInterface $parent, $use_id_path = true)
    {
        $id_with_namespace = static::addIdSpace($id_space, $id);
        if ($widget = $this->widgets[$id_with_namespace]) {
            // FIXME Check if one of the ancestors of the widget really is the given parent. Although this should always
            // be the case, but better doublecheck ist.
            return $widget;
        }
        
        $parentId = $parent->getId();
        // If the parent has a user-defined id, it will be accessible by both: autogenerated and
        // user-defined id.
        if ($id === $parentId || $id === $parent->getIdAutogenerated()) {
            return $parent;
        }
        
        if (StringDataType::startsWith($id_space, $parentId . self::WIDGET_ID_SEPARATOR)) {
            $id_space_root = $this->getWidget($id_space, $parent);
            return $this->getWidgetFromIdSpace($id, $id_space, $id_space_root);
        }
        
        // See if the id searched for has an id space
        $subjIdSpace = StringDataType::substringBefore($id_with_namespace, self::WIDGET_ID_SPACE_SEPARATOR, false, false, true);
        if ($subjIdSpace) {
            $subjIdInSpace = substr($id_with_namespace, (strlen($subjIdSpace) + 1));
        }
        
        $id_is_path = StringDataType::startsWith($id_with_namespace, $parentId . self::WIDGET_ID_SEPARATOR);
        // TODO not sure, if matching id spaces should be treated as $id_is_path too... No real-life examples found!
        //            || ($parent->getIdSpace() === $subjIdSpace && StringDataType::startsWith($subjIdInSpace, $parentId . self::WIDGET_ID_SPACE_SEPARATOR));
        
        foreach ($parent->getChildren() as $child) {
            $child_id = $child->getId();
            // Since the autogenerated id does not contain user-provided ids anymore since 16.09.2022 
            // (see generateWidgetId()), we need to check if the id we search for matches each childs 
            // id OR its autogenerated id.
            $child_id_path = $child->getIdAutogenerated();
            if ($child_id === $id_with_namespace || $child_id_path === $id_with_namespace) {
                return $child;
            } elseif ($subjIdSpace && $child->getIdSpace() === $subjIdSpace && ($subjIdInSpace === $child_id || $subjIdInSpace === $child_id_path)) {
                return $child;
            } else {
                $subjIdStartsWithChildId = StringDataType::startsWith($id_with_namespace, $child_id . self::WIDGET_ID_SEPARATOR) || StringDataType::startsWith($id_with_namespace, $child_id_path . self::WIDGET_ID_SEPARATOR);
                
                // If the subject id has an id space and we are in that id space, than it is
                // obvious, that searching in widgets, that have a different id space makes
                // no sense. Here we check if the child has a different id space and simply
                // continue with the next child in this case.
                // NOTE: there have been cases, where a widget has a chained id space, but only
                // part of it inside the actual id. It seem, this has something to do with the
                // fact, that only user-defined ids include the id space really. This is why we
                // check, if the searched id start with the child id here additionally - in these
                // strange cases, the parent id space is longer, than that of the searched id.
                if ($subjIdSpace && $parent->getIdSpace() === $subjIdSpace && ! $subjIdStartsWithChildId) {
                    if ($child->getIdSpace() !== $subjIdSpace) {
                        continue;
                    }
                }
                
                if (! $use_id_path || ! $id_is_path || $subjIdStartsWithChildId) {
                    // If we are looking for a non-path id or the path includes the id of the child, look within the child
                    try {
                        // Note, the child may deside itself, whe
                        return $this->getWidgetFromIdSpace($id, $id_space, $child);
                    } catch (WidgetNotFoundError $e) {
                        // Catching the error means, we did not find the widget in this branch.
                        
                        if ($id_is_path) {
                            // If we had a path-match, this probably means, that the widget was moved (see example 4 in
                            // the method-docblock). In this case, the path in it's id does not match the real path anymore.
                            // However, since this mostly happens when widgets get moved around within their parent, we
                            // try a deep search within the child, that matched the id-path, first. This will help in
                            // example 4 too, as the widget was just moved one level up the tree.
                            try {
                                // Setting the parameter $use_id_path to false makes the children search among their
                                // children even if those don't match the path. In example 4 we would get to this line
                                // after searching the child DT_TB_BG_BT2 of widget DT_TB_BG. DT_TB_BG_BT2 itself
                                // seems to match the path, but none of it's direct children do. Now we tell the
                                // DT_TB_BG_BT2 to treat the id as a non-path. This will make it pass the search
                                // to every child of DT_TB_BG_BT2. These will search regularly though, so stargin
                                // from DT_TB_BG_BT2_DT the path-idea will work again.
                                return $this->getWidgetFromIdSpace($id, $id_space, $child, false);
                            } catch (WidgetNotFoundError $ed) {
                                // If the deep-search fails too, we know, the widget was moved somewehere else (example 5)
                                // or the really does not exist. In this case, we stop looking through children (no other
                                // children will match the path anyway).
                                break;
                            }
                        } else {
                            // For non-path ids just continue with the next child as we do not know, where the id might be.
                            continue;
                        }
                    }
                } elseif ($id_is_path) {
                    // If the id is a path, but did not include the child id, continue with the next child
                    continue;
                }
            }
        }
            
        // At this point, we know, the widget was not found by the regular search methods.
        // There are two possibilities left:
        // 1) The id seemed to be a path and worked upto the current parent widget
        // 2) The id is not a path
        // TODO We still need some kind of fallback for example 5 here!
        
        throw new WidgetNotFoundError('Widget "' . $id . '" not found in id space "' . $id_space . '" within parent "' . $parent->getId() . '" on page "' . $this->getAliasWithNamespace() . '"!');
        
        return;
    }

    private static function addIdSpace($id_space, $id)
    {
        return (is_null($id_space) || $id_space === '' ? '' : $id_space . static::WIDGET_ID_SPACE_SEPARATOR) . $id;
    }
    
    /**
     * Autogenerated ids are basically paths of ids from the root widget to the given one.
     * 
     * This makes it possible to find a widget in a page pretty quickly even if it was not
     * instantiated yet - see search logic in `getWidgetFromIdSpacd()`. In this case, the idea
     * is to avoid having to instantiate all widgets, but just move along the id path. Thus,
     * each widget gets an autogenerated path-like id and may also have a user-defined id.
     * Both can be used to search for the widget, but the autogenerated ids shoul be faster
     * in general.
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::generateWidgetId()
     */
    public function generateWidgetId(WidgetInterface $widget, string $group = null, bool $makeUnique = true) : string
    {
        if (null !== $parent = $widget->getParent()) {
            // The autogenerated ids always build upon each-other to aviod custom ids interrupting
            // the path structure.
            $id = $parent->getIdAutogenerated() . self::WIDGET_ID_SEPARATOR;
        } else {
            $id = '';
        }
        $id .= $widget->getWidgetType();
        if ($group !== null) {
            $id .= self::WIDGET_ID_SEPARATOR . $group;
        }
        if ($makeUnique === true) {
            $id = $this->makeWidgetIdUnique($id);
        }
        return $id;
    }

    /**
     * Makes sure, the given widget id is unique in this page.
     * If not, the id gets a numeric index, which makes it unique.
     * Thus, the returned value is guaranteed to be unique!
     *
     * @param string $string            
     * @return string
     */
    protected function makeWidgetIdUnique(string $string) : string
    {
        if (null !== ($this->widgets[$string] ?? null)) {
            $index = substr($string, - 2);
            if (is_numeric($index)) {
                $index_new = str_pad(intval($index) + 1, 2, 0, STR_PAD_LEFT);
                $string = substr($string, 0, - 2) . $index_new;
            } else {
                $string .= '02';
            }
            
            return $this->makeWidgetIdUnique($string);
        }
        return $string;
    }

    /**
     *
     * @param string $widget_type            
     * @param WidgetInterface $parent_widget            
     * @param string $widget_id            
     * @return WidgetInterface
     */
    public function createWidget($widget_type, WidgetInterface $parent_widget = null, UxonObject $uxon = null)
    {
        if ($uxon) {
            $uxon->setProperty('widget_type', $widget_type);
            $widget = WidgetFactory::createFromUxon($this, $uxon, $parent_widget);
        } else {
            $widget = WidgetFactory::create($this, $widget_type, $parent_widget);
        }
        return $widget;
    }

    /**
     *
     * @param string $widget_id            
     * @return \exface\Core\CommonLogic\Model\UiPage
     */
    public function removeWidgetById($widget_id)
    {
        $widget = $this->widgets[$widget_id] ?? null;
        if ($widget !== null) {
            $this->getWorkbench()->eventManager()->dispatch(new OnRemoveEvent($widget));
        }
        unset($this->widgets[$widget_id]);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\Model\UiPageInterface::removeWidget()
     */
    public function removeWidget(WidgetInterface $widget, bool $remove_children_too = true) : UiPageInterface
    {
        if ($remove_children_too) {
            foreach ($this->widgets as $cached_widget) {
                if ($cached_widget->getParent() === $widget) {
                    $this->removeWidget($cached_widget, true);
                }
            }
        }
        $result = $this->removeWidgetById($widget->getId());
        return $result;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::removeAllWidgets()
     */
    public function removeAllWidgets() : UiPageInterface
    {
        foreach ($this->widgets as $cached_widget) {
            $this->removeWidgetById($cached_widget->getId());
        }
        $this->widgets = [];
        $this->widget_root = null;
        
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WorkbenchDependantInterface::getWorkbench()
     */
    public function getWorkbench()
    {
        return $this->getSelector()->getWorkbench();
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getWidgetIdSpaceSeparator()
     */
    public function getWidgetIdSpaceSeparator()
    {
        return self::WIDGET_ID_SPACE_SEPARATOR;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::isEmpty()
     */
    public function isEmpty()
    {
        return $this->getWidgetRoot() ? false : true;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getContextBar()
     */
    public function getContextBar()
    {
        if (is_null($this->context_bar)) {
            $this->context_bar = WidgetFactory::create($this, 'ContextBar');
        }
        return $this->context_bar;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::isUpdateable()
     */
    public function isUpdateable()
    {
        return $this->updateable;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setUpdateable()
     */
    public function setUpdateable($true_or_false)
    {
        if (! is_null($true_or_false)) {
            // BooleanDataType::cast() ist sehr restriktiv darin einen Wert als true zurueckzugeben,
            // im Zweifelsfall wird false zurueckgegeben. Updatetable sollte aber im Zweifelsfall
            // eher true sein.
            $this->updateable = BooleanDataType::cast($true_or_false);
        }
        
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getParentPage()
     */
    public function getParentPage(bool $ignoreReplacement = false) : ?UiPageInterface
    {
        if ($this->getParentPageSelector() !== null) {
            return UiPageFactory::createFromModel($this->getWorkbench(), $this->getParentPageSelector(), $ignoreReplacement);
        }
        return null;
    }

    /**
     * Returns the selector (id or alias) for the parent page in the main menu or NULL if no parent defined.
     * 
     * @return UiPageSelectorInterface|null
     */
    public function getParentPageSelector() : ?UiPageSelectorInterface
    {
        if ($this->menuParentPageSelector !== null && is_string($this->menuParentPageSelector)) {
            $this->menuParentPageSelector = SelectorFactory::createPageSelector($this->getWorkbench(), $this->menuParentPageSelector);
        }
        return $this->menuParentPageSelector;
    }
    
    /**
     * The page selector for the parent page in the menu
     * 
     * @uxon-property menu_parent_page_selector
     * @uxon-type metamodel:page
     * 
     * @param string $id_or_alias
     * @return \exface\Core\Interfaces\Model\UiPageInterface
     */
    private function setMenuParentPageSelector($id_or_alias)
    {
        return $this->setParentPageSelector($id_or_alias);
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setParentPageSelector()
     */
    public function setParentPageSelector($idOrAliasOrNull)
    {
        $this->menuParentPageSelector = $idOrAliasOrNull;
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getMenuIndex()
     */
    public function getMenuIndex() : int
    {
        return $this->menuIndex ?? 0;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setMenuIndex()
     */
    public function setMenuIndex($number) : UiPageInterface
    {
        $this->menuIndex = $number === null ? null : NumberDataType::cast($number);
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::isMoved()
     */
    public function isMoved()
    {
        $defaultsExist = $this->getMenuIndexDefault() !== null && $this->getParentPageSelectorDefault() !== null;
        $differentParent = strcasecmp($this->getParentPageSelector(), $this->getParentPageSelectorDefault()) !== 0;
        $differentIndex = $this->getMenuIndex() !== $this->getMenuIndexDefault();
        return $defaultsExist === true && ($differentParent || $differentIndex);
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getMenuVisible()
     */
    public function getMenuVisible()
    {
        return $this->menuVisible;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setMenuVisible()
     */
    public function setMenuVisible($menuVisible)
    {
        if (! is_null($menuVisible)) {
            $this->menuVisible = BooleanDataType::cast($menuVisible);
        }
        return $this;
    }

    /**
     *
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getUid()
     */
    public function getUid() : ?string
    {
        if (is_null($this->id) && $this->selector->isUid()) {
            $this->setId($this->selector->toString());
        }
        return $this->id;
    }

    /**
     * @deprecated use getUid() instead
     * 
     * @return string|NULL
     */
    public function getId()
    {
        return $this->getUid();
    }
    
    /**
     * The UID of the page
     * 
     * @uxon-property id
     * @uxon-type string
     * 
     * @param string $uid
     * @return UiPageInterface
     */
    private function setId(string $uid) : UiPageInterface
    {
        return $this->setUid($uid);
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setUid()
     */
    public function setUid(string $uid) : UiPageInterface
    {
        $this->id = $uid;
        if ($this->getSelector()->isEmpty()) {
            $this->selector = SelectorFactory::createPageSelector($this->getWorkbench(), $uid);
        }
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiMenuItemInterface::getName()
     */
    public function getName() : string
    {
        return $this->name;
    }

    /**
     * The name of the page in the default language of it's app
     * 
     * @uxon-property name
     * @uxon-type string
     * @uxon-required true
     * 
     * @see \exface\Core\Interfaces\Model\UiMenuItemInterface::setName()
     */
    public function setName($string) : UiMenuItemInterface
    {
        $this->name = $string;
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiMenuItemInterface::getDescription()
     */
    public function getDescription() : ?string
    {
        return $this->description;
    }
    
    /**
     * A short description for the page in the default language of it's app
     * 
     * @uxon-property description
     * @uxon-type string
     * 
     * @see \exface\Core\Interfaces\Model\UiMenuItemInterface::setDescription()
     */
    public function setDescription(string $string) : UiMenuItemInterface
    {
        $this->description = $string;
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiMenuItemInterface::getIntro()
     */
    public function getIntro() : ?string
    {
        return $this->intro;
    }

    /**
     * An long description (introduction) for the page
     * 
     * @uxon-property intro
     * @uxon-type string
     * 
     * @see \exface\Core\Interfaces\Model\UiMenuItemInterface::setIntro()
     */
    public function setIntro(string $text) : UiMenuItemInterface
    {
        $this->intro = $text;
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getReplacesPageSelector()
     */
    public function getReplacesPageSelector() : ?UiPageSelectorInterface
    {
        if ($this->replacesPageSelector !== null && is_string($this->replacesPageSelector)) {
            $this->replacesPageSelector = SelectorFactory::createPageSelector($this->getWorkbench(), $this->replacesPageSelector);
        }
        return $this->replacesPageSelector;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setReplacesPageSelector()
     */
    public function setReplacesPageSelector($uidOrAlias)
    {
        $this->replacesPageSelector = $uidOrAlias;
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getContents()
     */
    public function getContents()
    {
        if (is_null($this->contents) && ! is_null($this->contents_uxon)) {
            $this->contents = $this->contents_uxon->toJson();
        }
        
        return $this->contents;
    }

    /**
     * Returns TRUE if the contents of the page was modified since the last time widgets were generated.
     * 
     * Run regenerateWidgetsFromContents() to make the page not dirty.
     * 
     * @return boolean
     */
    protected function isDirty()
    {
        return $this->dirty;
    }

    /**
     * Marks this page as dirty: all widgets will be removed immediately and will get regenerated the next 
     * time the user requests a widget.
     * 
     * @return \exface\Core\CommonLogic\Model\UiPage
     */
    private function setDirty()
    {
        $this->removeAllWidgets();
        $this->dirty = true;
        return $this;
    }

    /**
     * UXON description of the page's content (widgets)
     * 
     * @uxon-property contents
     * @uxon-type \exface\Core\Widgets\AbstractWidget
     * 
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setContents()
     */
    public function setContents($contents)
    {
        $this->setDirty();
        
        if (is_string($contents)) {
            $this->contents = trim($contents);
        } elseif ($contents instanceof UxonObject) {
            $this->contents_uxon = $contents;
        } else {
            throw new InvalidArgumentException('Cannot set contents from ' . gettype($contents) . ': expecting string or UxonObject!');
        }
        
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\AliasInterface::getAlias()
     */
    public function getAlias()
    {
        if (($sepPos = strrpos($this->getAliasWithNamespace(), AliasSelectorInterface::ALIAS_NAMESPACE_DELIMITER)) !== false) {
            $alias = substr($this->getAliasWithNamespace(), $sepPos + 1);
        } else {
            $alias = $this->getAliasWithNamespace();
        }
        return $alias;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\AliasInterface::getAliasWithNamespace()
     */
    public function getAliasWithNamespace()
    {
        if ($this->aliasWithNamespace === null && $this->selector->isAlias()) {
            $this->aliasWithNamespace = $this->selector->toString();
        }
        return $this->aliasWithNamespace;
    }

    /**
     * Sets the alias of the page.
     * 
     * @param string $aliasWithNamespace
     * @return UiPageInterface
     */
    protected function setAliasWithNamespace($aliasWithNamespace)
    {
        if ($this->getSelector()->isEmpty()) {
            $this->selector = SelectorFactory::createPageSelector($this->getWorkbench(), $aliasWithNamespace);
        }
        $this->aliasWithNamespace = $aliasWithNamespace;
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\AliasInterface::getNamespace()
     */
    public function getNamespace()
    {
        if (($sepPos = strrpos($this->getAliasWithNamespace(), AliasSelectorInterface::ALIAS_NAMESPACE_DELIMITER)) !== false) {
            $namespace = substr($this->getAliasWithNamespace(), 0, $sepPos);
        } else {
            $namespace = '';
        }
        return $namespace;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\iCanBeConvertedToUxon::exportUxonObject()
     */
    public function exportUxonObject()
    {
        /** @var UxonObject $uxon */
        $uxon = new UxonObject();
        $uxon->setProperty('uid', $this->getUid());
        $uxon->setProperty('alias_with_namespace', $this->getAliasWithNamespace());
        if ($this->isMenuHome()) {
            $uxon->setProperty('menu_home', $this->isMenuHome());
        }
        $uxon->setProperty('menu_parent_page_selector', $this->isMenuHome() || ! $this->hasParent() ? null : $this->getParentPageSelector()->toString());
        $uxon->setProperty('menu_index', $this->getMenuIndex());
        $uxon->setProperty('menu_visible', $this->getMenuVisible());
        $uxon->setProperty('name', $this->getName());
        $uxon->setProperty('description', $this->getDescription());
        $uxon->setProperty('intro', $this->getIntro());
        $uxon->setProperty('replaces_page_selector', $this->getReplacesPageSelector());
        $uxon->setProperty('created_by_user_selector', $this->getCreatedByUserSelector()->toString());
        $uxon->setProperty('created_on', $this->getCreatedOn());
        $uxon->setProperty('modified_by_user_selector', $this->getModifiedByUserSelector()->toString());
        $uxon->setProperty('modified_on', $this->getModifiedOn());
        
        if (null !== ($val = $this->getIcon()) && $val !== '') {
            $uxon->setProperty('icon', $val);
        }
        if (null !== ($val = $this->getIconSet()) && $val !== '') {
            $uxon->setProperty('icon_set', $val);
        }
        
        $contents = trim($this->getContents());
        if (! $contents) {
            // contents == null
            $contents = '';
        } else {
            if (substr($contents, 0, 1) == '{' && substr($contents, - 1) == '}') {
                // contents == UxonObject
                $contents = UxonObject::fromJson($contents);
                if ($contents->isEmpty()) {
                    $contents = '';
                }
            } else {
                // contents == string
                $contents = $this->getContents();
            }
        }
        $uxon->setProperty('contents', $contents);
        
        return $uxon;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::copy()
     */
    public function copy($page_alias = null, $page_uid = null, AppSelectorInterface $appSelector = null) : UiPageInterface
    {
        $copy = UiPageFactory::createFromUxon($this->getWorkbench(), $this->exportUxonObject());
        if (! is_null($page_uid)) {
            $copy->setId($page_uid);
        }
        if (! is_null($page_alias)) {
            $copy->setAliasWithNamespace($page_alias);
        }
        // Copy internal properties, that do not get exported to UXON
        if (! is_null($appSelector)) {
            $copy->setApp($appSelector);
        } else {
            $copy->setApp($this->$appSelector);
        }
        if ($this->getMenuIndexDefault() !== null) {
            $copy->setMenuIndexDefault($this->getMenuIndexDefault());
        }
        if ($this->getParentPageSelectorDefault() !== null) {
            $copy->setParentPageSelectorDefault($this->getParentPageSelectorDefault());
        }
        return $copy;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::is()
     */
    public function is($pageOrSelectorOrString) : bool
    {
        if ($this->isExactly($pageOrSelectorOrString)) {
            // Die uebergebene Seite ist genau diese Seite.
            return true;
        }
        
        if (! $pageOrSelectorOrString instanceof UiPageInterface) {
            try {
                $selector = $pageOrSelectorOrString instanceof UiPageSelectorInterface ? $pageOrSelectorOrString : SelectorFactory::createPageSelector($this->getWorkbench(), $pageOrSelectorOrString);
                $page = UiPageFactory::createFromModel($this->getWorkbench(), $selector, true);
            } catch (UiPageNotFoundError $upnfe) {
                return false;
            }
        } else {
            $page = $pageOrSelectorOrString;
        }
        
        if ($page->getReplacesPageSelector() && $this->compareToPageReplace($this, $page)) {
            // Ersetzt die uebergebene Seite eine andere Seite, koennte es diese Seite sein (auch
            // ueber eine Kette von Ersetzungen).
            return true;
        } elseif ($this->getReplacesPageSelector() && $this->compareToPageReplace($page, $this)) {
            // Ersetzt diese Seite eine andere Seite, koennte es die uebergebene Seite sein (auch
            // ueber eine Kette von Ersetzungen).
            return true;
        }
        
        // Leider waeren hier fuer eine exakte Pruefung bei laengeren Ketten von Ersetzungen auf
        // beiden Seiten eine exponentiell zunehmende Anzahl von Vergleichen zu tun.
        
        return false;
    }

    /**
     * This function compares two pages and returns if they are equal.
     * 
     * It first reloads page1 and then compares it to page2. So it also returns true if
     * page1 is replaced by page2.
     * 
     * @param UiPageInterface $page1
     * @param UiPageInterface $page2
     * @return boolean
     */
    protected function compareToPageReplace(UiPageInterface $page1, UiPageInterface $page2)
    {
        try {
            $replacedPage = UiPageFactory::createFromModel($this->getWorkbench(), $page1->getSelector());
        } catch (UiPageNotFoundError $uipnfe) {
            return false;
        }
        if ($replacedPage->isExactly($page2)) {
            return true;
        }
        
        return false;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::isExactly()
     */
    public function isExactly($pageOrSelectorOrString) : bool
    {
        if ($pageOrSelectorOrString instanceof UiPageInterface) {
            return $this->getUid() === $pageOrSelectorOrString->getUid();
        }
        
        if ($pageOrSelectorOrString instanceof UiPageSelectorInterface) {
            $selector = $pageOrSelectorOrString;
        } else {
            $selector = SelectorFactory::createPageSelector($this->getWorkbench(), $pageOrSelectorOrString);
        }
        
        if ($selector->isUid() === true) {
            return $this->getUid() === $selector->toString();
        }
        if ($selector->isAlias() === true) {
            return strcasecmp($this->getAliasWithNamespace(), $selector->toString()) === 0;
        }
        
        throw new RuntimeException('Cannot compare page "' . $this->getAliasWithNamespace() . '" to selector "' . $selector->toString() . '": unknown selector type!');
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getSelector()
     */
    public function getSelector() : UiPageSelectorInterface
    {
        return $this->selector;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getFacade()
     */
    public function getFacade() : FacadeInterface
    {
        if ($this->facade === null) {
            if ($this->facadeSelector !== null) {
                $this->facade = FacadeFactory::createFromAnything($this->facadeSelector, $this->getWorkbench());
            } else {
                $this->facade = FacadeFactory::createDefaultHttpFacade($this->getWorkbench());
            }
            if ($this->facadeUxon !== null) {
                $this->facade->importUxonObject($this->facadeUxon);
            }
        }
        return $this->facade;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setFacadeSelector()
     */
    public function setFacadeSelector($selectorOrString) : UiPageInterface
    {
        $this->facadeSelector = $selectorOrString;
        $this->facade = null;
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::isFacadeSet()
     */
    public function isFacadeSet() : bool
    {
        return $this->facadeSelector !== NULL;
    }

    /**
     * 
     * @param UxonObject $uxon
     * @throws LogicException
     * @return UiPageInterface
     */
    public function setFacadeConfig(UxonObject $uxon) : UiPageInterface
    {
        $this->facadeUxon = $uxon;
        if ($this->facade !== null) {
            throw new LogicException('Cannot modify facade configuration for a page after the facade had been loaded!');
        }
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setParentPageSelectorDefault()
     */
    public function setParentPageSelectorDefault($selectorOrStringOrNull): UiPageInterface
    {
        $this->menuParentPageSelectorDefault = $selectorOrStringOrNull;
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::hasModel()
     */
    public function hasModel() : bool
    {
        return $this->contents !== null || $this->contents_uxon !== null;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getMenuIndexDefault()
     */
    public function getMenuIndexDefault(): ?int
    {
        return $this->menuIndexDefault;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setMenuIndexDefault()
     */
    public function setMenuIndexDefault(int $number): UiPageInterface
    {
        $this->menuIndexDefault = $number;
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getParentPageSelectorDefault()
     */
    public function getParentPageSelectorDefault(): ?UiPageSelectorInterface
    {
        if ($this->menuParentPageSelectorDefault !== null && is_string($this->menuParentPageSelectorDefault)) {
            $this->menuParentPageSelectorDefault = SelectorFactory::createPageSelector($this->getWorkbench(), $this->menuParentPageSelectorDefault);
        }
        return $this->menuParentPageSelectorDefault;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::hasParent()
     */
    public function hasParent() : bool
    {
        return $this->menuParentPageSelector !== null;
    }

    /**
     * @deprecated use setParentPageSelector() instead!
     * @param string $aliasWithNamespace
     * @return UiPageInterface
     */
    protected function setParentPageAlias(string $aliasWithNamespace) : UiPageInterface
    {
        return $this->setParentPageSelector($aliasWithNamespace);
    }
    
    /**
     * @deprecated use setParentPageSelector() instead!
     * @param string $aliasWithNamespace
     * @return UiPageInterface
     */
    private function setMenuParentPageAlias(string $aliasWithNamespace) : UiPageInterface
    {
        return $this->setParentPageSelector($aliasWithNamespace);
    }
    
    /**
     * @deprecated use setReplacesPageSelector() instead!
     * @param string|null $aliasWithNamespace
     * @return UiPageInterface
     */
    protected function setReplacesPageAlias($aliasWithNamespace) : UiPageInterface
    {
        if ($aliasWithNamespace === null) {
            return $this;
        }
        return $this->setReplacesPageSelector($aliasWithNamespace);
    }
    
    public function exportDataRow(DataSheetInterface $dataSheet) : DataSheetInterface
    {
        $createdBySelector = $this->getCreatedByUserSelector();
        if ($createdBySelector->isUid()) {
            $createdByUid = $createdBySelector->toString();
        } else {
            $createdByUid = UserFactory::createFromSelector($createdBySelector)->getUid();
        }
        $modifiedBySelector = $this->getModifiedByUserSelector();
        if ($modifiedBySelector->isUid()) {
            $modifiedByUid = $modifiedBySelector->toString();
        } else {
            $modifiedByUid = UserFactory::createFromSelector($modifiedBySelector)->getUid();
        }
        $dataSheet->addRow([
            'UID' => $this->getUid(),
            'ALIAS' => $this->getAliasWithNamespace(),
            'APP' => $this->hasApp() ? $this->getApp()->getUid() : null,
            'AUTO_UPDATE_WITH_APP' => $this->isUpdateable(),
            'CONTENT' => $this->getContents(),
            'DEFAULT_MENU_INDEX' => $this->getMenuIndexDefault(),
            'DEFAULT_MENU_PARENT' => $this->getParentPageSelectorDefault() !== null ? $this->getPageUidFromSelector($this->getParentPageSelectorDefault()) : null,
            'DESCRIPTION' => $this->getDescription(),
            'ICON' => $this->getIcon(),
            'ICON_SET' => $this->getIconSet(),
            'INTRO' => $this->getIntro(),
            'MENU_HOME' => $this->isMenuHome(),
            'MENU_PARENT' => $this->hasParent() ? $this->getPageUidFromSelector($this->getParentPageSelector()) : null,
            'MENU_POSITION' => $this->getMenuIndex(),
            'MENU_VISIBLE' => $this->getMenuVisible(),
            'NAME' => $this->getName(),
            'REPLACE_PAGE' => $this->getReplacesPageSelector() !== null ? $this->getPageUidFromSelector($this->getReplacesPageSelector()) : null,
            'PUBLISHED' => $this->isPublished(),
            'CREATED_BY_USER' => $createdByUid,
            'CREATED_ON' => $this->getCreatedOn(),
            'MODIFIED_BY_USER' => $modifiedByUid,
            'MODIFIED_ON' => $this->getModifiedOn()
        ]);
        
        return $dataSheet;
    }
    
    private function getPageUidFromSelector(UiPageSelectorInterface $selector) : string
    {
        if ($selector->isUid()) {
            return $selector->toString();
        }
        return UiPageFactory::createFromModel($this->getWorkbench(), $selector)->getUid();
    }
    
    /**
     * Set to TRUE to make this page be exported/installed as top-level item of the main menu - regardless of its current position.
     *
     * This option allows developers to decouple the menu structure in their dev-environment
     * from the menu in production: a page may put in a subfolder on dev and still land at
     * "home"-level in production.
     *
     * @uxon-property menu_home
     * @uxon-type boolean
     * @uxon-default false
     * 
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setMenuHome()
     */
    public function setMenuHome(bool $trueOrFalse) : UiPageInterface
    {
        $this->menuHome = $trueOrFalse;
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::isMenuHome()
     */
    public function isMenuHome() : bool
    {
        return $this->menuHome;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::setPWASelector()
     */
    public function setPWASelector($selectorOrString) : UiPageInterface
    {
        $this->pwaSelector = $selectorOrString;
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::isPWA()
     */
    public function isPWA() : bool
    {
        return $this->pwaSelector !== null;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\UiPageInterface::getPWASelector()
     */
    public function getPWASelector() : ?PWASelectorInterface
    {
        if (is_string($this->pwaSelector)) {
            $this->pwaSelector = new PWASelector($this->getWorkbench(), $this->pwaSelector);
        }
        return $this->pwaSelector;
    }
}