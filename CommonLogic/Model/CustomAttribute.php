<?php

namespace exface\Core\CommonLogic\Model;

use exface\Core\CommonLogic\Selectors\MetaObjectSelector;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\DataTypes\MetaAttributeOriginDataType;
use exface\Core\DataTypes\PhpClassDataType;
use exface\Core\DataTypes\RelationCardinalityDataType;
use exface\Core\Factories\MetaObjectFactory;
use exface\Core\Interfaces\Model\BehaviorInterface;
use exface\Core\Interfaces\Model\MetaAttributeInterface;
use exface\Core\Interfaces\Model\MetaObjectInterface;

/**
 * Custom attributes are meant to be added to objects at runtime.
 * 
 * Apart from some minor convenience features, they work the same as regular attributes. You can set most
 * properties seen in the attribute editor UI via UXON.
 * 
 * @see \exface\Core\Behaviors\CustomAttributeDefinitionBehavior
 */
class CustomAttribute extends Attribute
{
    private mixed $source = null;
    private ?int $sourceIndex = null;
    private ?string $typeModel = null;

    /**
     *
     * @param MetaObjectInterface $object
     * @param string $name
     * @param string $alias
     * @param object|null $source
     * @param int|null $sourceIndex
     */
    public function __construct(MetaObjectInterface $object, string $name, string $alias, object $source = null, int $sourceIndex = null)
    {
        $this->source = $source;
        $this->sourceIndex = $sourceIndex;    
        parent::__construct($object, $name, $alias);
    }

    /**
     * The source of this custom attribute. 
     * 
     * The source represents the caller that initiated the creation of this object.
     * Bear in mind that it might be null.
     * 
     * NOTE: this property is read-only. You cannot set it in UXON manually!
     * 
     * @uxon-property source
     * @uxon-type string
     * 
     * @return mixed
     */
    public function getSource() : mixed
    {
        return $this->source;
    }

    /**
     * The sequence number of the attribute as generated by its source (starting with 0)
     * 
     * NOTE: this property is read-only. You cannot set it in UXON manually!
     * 
     * @uxon-property source_index
     * @uxon-type number
     * 
     * @return int|null
     */
    public function getSourceIndex() : ?int
    {
        return $this->sourceIndex;
    }

    /**
     * 
     * @return string
     */
    public function getSourceHint() : string
    {
        $src = $this->getSource();
        switch (true) {
            case $src instanceof BehaviorInterface:
                $hint = PhpClassDataType::findClassNameWithoutNamespace($src) . ' "' . $src->getName() . '"';
                break;
            case $src instanceof \Stringable:
                $hint = $src->__toString();
                break;
            case $src === null:
                $hint = 'unknown source';
                break;
            default:
                $hint = PhpClassDataType::findClassNameWithoutNamespace($src);
                break;
        }
        return $hint;
    }    

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Model\MetaAttributeInterface::getOrigin()
     */
    public function getOrigin() : int
    {
        return MetaAttributeOriginDataType::CUSTOM_ATTRIBUTE;
    }

    /**
     * @return string|null
     */
    public function getTypeModel(): ?string
    {
        return $this->typeModel;
    }

    /**
     * @param string|null $typeModel
     * @return void
     */
    public function setTypeModel(?string $typeModel): void
    {
        $this->typeModel = $typeModel;
    }

    /**
     * Make this attribute a relation
     *
     * Similarly to the object editor UI, you can set additional relation properties here:
     *
     * ```
     * {
     *     "relation": {
     *          "related_object_alias": "my.App.OBJ_ALIAS",
     *          "related_object_key_attribute_alias": "NON_UID_ATTRIBUTE",
     *          "relation_cardinality": "N1",
     *          "copy_with_related_object": false,
     *          "delete_with_related_object": true
     *     }
     * }
     * ```
     *
     * @uxon-property relation
     * @uxon-type \exface\Core\CommonLogic\Model\Relation
     * @uxon-template {"related_object_alias": ""}
     *
     * @param UxonObject $uxon
     * @return MetaAttributeInterface
     */
    protected function setRelation(UxonObject $uxon) : MetaAttributeInterface
    {
        $workbench = $this->getWorkbench();

        // The logic here is similar to SqlModelLoader::loadObject(). Once we have an attribute and we know, it is
        // a relation, we need to generate relation instances for this object and the related object - the forward
        // and reverse relations.

        // First create a relation for this attribute and add it to this attributes object
        $rightSelector = new MetaObjectSelector($this->getWorkbench(), $uxon->getProperty('related_object_alias'));
        $rightObj = MetaObjectFactory::createFromSelector($rightSelector);
        $rightObjUid = $rightSelector->isUid() ? $rightSelector->toString() : $rightObj->getId();

        // See if we need a custom right-side key (if not, we will assume the UID of the right object)
        $relatedKeyAttrSelector = $uxon->getProperty('related_object_key_attribute_alias');
        $relatedKeyAttrId = null;
        if ($relatedKeyAttrSelector !== null) {
            if (mb_substr($relatedKeyAttrSelector, 0, 2) === '0x') {
                $relatedKeyAttrId = $relatedKeyAttrSelector;
            } else {
                $relatedKeyAttrId = $rightObj->getAttribute($relatedKeyAttrSelector);
            }
        }
        
        // First create the forward relation
        $cardinality = $uxon->hasProperty('relation_cardinality') ? RelationCardinalityDataType::fromValue($workbench, $uxon->getProperty('relation_cardinality')) : RelationCardinalityDataType::N_TO_ONE($workbench);
        $rel = new Relation(
            $workbench,
            $cardinality,
            $this->getId(), // relation id
            $this->getAlias(), // relation alias
            '', // alias modifier allways empty for direct regular relations
            $this->getObject(), //  left object
            $this, // left key attribute
            $rightObjUid, // right object UID
            $relatedKeyAttrId // related object key attribute (UID will be used if not set)
        );
        // Set other relation properteis
        if ($uxon->getProperty('delete_with_related_object') === true) {
            $rel->setLeftObjectToBeDeletedWithRightObject(true);
        }
        if ($uxon->getProperty('copy_with_related_object') === true) {
            $rel->setLeftObjectToBeCopiedWithRightObject(true);
        }
        $this->setRelationFlag(true);
        // Add the relation to this attributes object (left object)
        $this->getObject()->addRelation($rel);

        // Now create the corresponding reverse relation and add it to the related (right) object
        $cardinality = RelationCardinalityDataType::fromValue($this->getWorkbench(), RelationCardinalityDataType::findCardinalityOfReverseRelation($cardinality));
        $rel = new Relation(
            $workbench,
            $cardinality,
            $this->getId(), // relation id
            $this->getObject()->getAlias(), // relation alias
            $this->getAlias(), // relation modifier: the alias of the right key attribute
            $rightObj, // left object
            $relatedKeyAttrId ? $rightObj->getAttributes()->getByAttributeId($relatedKeyAttrId) : $rightObj->getUidAttribute(), // left key in the main object
            $this->getObject()->getId(), // right object UID
            $this->getId() // right object key attribute id
        );
        // Set other relation properteis
        if ($uxon->getProperty('delete_with_related_object') === true) {
            $rel->setLeftObjectToBeDeletedWithRightObject(true);
        }
        if ($uxon->getProperty('copy_with_related_object') === true) {
            $rel->setLeftObjectToBeCopiedWithRightObject(true);
        }
        // Add the relation to the other (right) object
        $rightObj->addRelation($rel);

        return $this;
    }

    public function exportUxonObject()
    {
        $uxon = parent::exportUxonObject();
        if ($this->sourceIndex !== null) {
            $uxon->setProperty('source_index', $this->sourceIndex);
        }
        if ($this->source !== null) {
            $uxon->setProperty('source', $this->source);
        }
        return $uxon;
    }
}