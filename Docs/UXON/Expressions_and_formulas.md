# Expressions and formulas

There are different types of expressons, that can be used within various parts of the model to reference other parts:

## Overview

| Expression type | Example | Description |
| --------------- | ------- | ----------- |
| Scalar values   | `1`, `'Text'`, `true` | Simple strings and numbers |
| [Model aliases](Aliases.md)   | `exface.Core.DATA_TYPE`, `APP` | Reference model entities like objects and attributes. Almost everything in the meta model has an alias. |
| Placeholders    | `[#title#]`, `[#~data:APP#]` | Allow to use variables inside textual templates |
| [Formulas](Formula_syntax.md)         | `=Now()`, `=SUM(ATTRIBUTE1, ATTRIBUTE2)` | Used to calculate values similarly to Excel. See [syntax overview](Formula_syntax.md) for details.            |
| Widget links    | `my_datatable_id`, `[my.app.page1]my_table_id` | Reference a widget by its id - even across pages |
| Live references | `=my_datatable_id!ATTRIBUTE1` | Reference the current "live" value in a widget |

## Static and data-driven expressions

There are two main categories of expressions: 
- static expressions do not depend on the data being handled, but may depend on the current context like the logged on user, the time, scalar values, etc.
- data-driven or non-static expressions 

## Model entity aliases 

Aliases are used for direct references to the model

### Examples:

- Widget property `object_alias`
- Widget property `attribute_alias`

## Placeholders

Many text values allow placeholders - e.g. properties of notifications, some formulas (see below), data addresses in most query builders, etc. Placeholders are enclosed in `[#` and `#]`, like this: `[#title#]`. In some cases, when many different sources for placeholders are supported, the require namespace prefixes: `[#~data:TITLE#]` where `~data:` would be the namespace, that is often used for input data (e.g. for a notification) and allows to use data sheet column names in placeholders. What kinds of placeholders are supported, depends on the specific property - see the corresponding documentation for details.

### Examples

- Placeholders in an SQL data address
	- `[#~alias#]` - resolves to the SQL table alias generated by the query builder
	- `[#APP#]` - resolves to the data address (e.g. SQL column) of the attribute `APP` of the current meta object
- Namespaced placeholders in the `NotifyingBehavior`:
	- `[#~config:app_alias:config_key#]` - will be replaced by the value of the `config_key` in the given app
	- `[#~translate:app_alias:translation_key#]` - will be replaced by the translation of the `translation_key` from the given app
	- `[#~data:column_name#]` - will be replaced by the value from `column_name` of the data sheet,for which the notification was triggered - only works with notification on data sheet events!
	- `[#=Formula()#]` - will evaluate the `Formula` (e.g. `=Now()`) in the context of the notification.
	This means, static formulas will always work, while data-driven formulas will only work on data sheet events!

## Scalar values

Scalar values are expressions too: strings, numbers, booleans (`true` and `false`) and `NULL`. Strings must be enclosed in quotes most of the time, while numbers, booleans and NULL can be used as-is. 

There are some exceptions, documented at the respective model property: e.g. the `value` of a `Filter` widget is treated as a string even if it is not enclosed in quotes.

## Formulas

Formulas are similar to those in Microsoft Excel. Many properties of widgets, behaviors and actions support formulas. A formula MUST start with `=` and may contain other formulas, model aliases, scalar values and mathematical/logical operators. See [detailed formula syntax guide](Formula_syntax.md) 

### Examples: 

- `=Now()` will be resolved to the current timestamp. This formula does not have any arguments. It is static because it does not depend on data.
- `=DateAdd(Now(), 7)` will add seven days to the current time stamp. It has two arguments: another formula and the scalar value `7`. It is still static becaus it does not require any data.
- `=DateAdd(SOME_DATE_ATTRIBUTE, 7)` will add 7 days to the date read from the attribute `SOME_DATE_ATTRIBUTE`. This formula is non-static because the first argument is a reference to the data model. The second argument is a scalar.
- `=ReplacePlaceholders('Delete [#NAME#]?')` - will replace the placeholder `[#NAME#]` with the contents of the corresponding data sheet column. This formula allows to use placehodlers in any other formula - even if if does not directly support them.

## Widget links

Each widget has a unique id on a UI page - automatically generad or defined manually via the `id` property. These ids are used to link widgets on the same page or even across pages by prefixing the id by the page alias.

- `my_datatable_id`
- `[my.app.page1]my_table_id`

## Live references to widget values

Now, that we can link to a widget, think of each widget as a visualization of an excel sheet: e.g. a `DataTable` has obviously rows and columns, an `Input` would be a sheet with only a single cell, a multi-select would be a single column with multiple rows, while an `InputComboTable` would select rows from a table.

We can use Excel-like expressions to reference values in these widgets:

- `=my_input_field` would fetch the current value from the `Input` with id `my_input_field`
- `=my_combo!ATTRIBUTE1` would fetch the value of column `ATTRIBUTE1` from the selected row in an `InputComboTable` with id `my_combo`
- `=my_table!ATTRIBUTE1` would get `ATTRIBUTE1` from the selected row of a `DataTable`
- `=my_table!ATTRIBUTE1$1` would get it from the first row

**NOTE**: the use of live references largely depends on the facade used to render a page. Not all facades support live refs, but if they do, the value will change immediately on user interaction.