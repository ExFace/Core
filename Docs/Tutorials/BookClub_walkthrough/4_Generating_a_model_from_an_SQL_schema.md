# Generating a metamodel from an SQL schema

Now that we have a [data source](3_Connecting_to_an_sql_database.md) we can start modeling the actual data. The core of the metamodel is a graph model of the business objects related to the app. This is similar to the relational model of an SQL database with the main difference being the focus on relations between these objects.

For a start it is safe to assume, that every database table should become a meta object with attributes for every column of that table. The same goes for views. This stub of a model can be easily generated with a single click. 

In fact, many types of data sources provide descriptive information about the structure of their data similarly to database schemas. Many data connectors provide so-called model builders, that can generate more-or-less detailed metamodels from this information. A detailed description of the capabilities of every model builder can be found in  `Administration > Documentation > Model Builders`.

## 1. Generate a simple meta object

To get familiar whith meta objects we will import a very simple table first - the [language](1_Preparation.md) table. It should contain book languages - the values of the dropdown menu to select the language for each book. The table has the following structure:

- `id` - an autogenerated unique integer value that identifies the entry technically
- `created_on` - date and time when the table entry was created
- `created_by_user_id` - UUID of the workbench user that created the entry
- `modified_on` - date and time when the table entry was last modified
- `modified_by_user_id` - UUID of the user that performed the last modification
- `name` - the name of the language in the app's default language (english)

The first five columns are system columns, that are present in all tables - which is a very common practice. The `name` is the only real property of a language.

It is a good idea to try to import such a minimal table before proceeding with the rest of the schema. As it will be shown below, identifying such "system columns" as above can save a lot of manual fine-tuning.

Now let's crate a meta object for the language.

1. Remain at `Administration > Metamodel > Data Sources` in the main menu.
2. Select the [newly created](3_Connecting_to_an_sql_database.md) ´BookClub DB´
3. Press `Generate Model` button
4. Fill the dialog fields as follows
	- Object Data Address Mask: `language` 
5. Press `Generate Model`
6. After the action succeeds, select the data source again and press the `Objects` button

This will send us one step further in the main menu to the list of meta objects. Since we wanted to see the objects of our app specifically, the list is already filtered by app. You should now see the new `Language` object in the table.

## 2. Get to know the meta object structure

Double click it to open the object editor (or press the `Edit` in the button). 

The object dialog is organized in tabs. Each tab has it's own focus and controls while the bottom button bar is available in all tabs.

Hover over the controls with the mouse pointer to see a short hint or press the `?` icon at the top of the dialog to open the contextual help with all the field descriptions listed.

### The `General` tab

The first tab we see contains general information about the meta object. As most components of the model, objects have names and aliases and are bound to apps. 

The alias of our object is `language` - the model builder simply used the name of the table. This is a good idea since it helps people who know the database schema to get around. Since the object is part of the app `tutorial.BookClub`, it's fully qualified alias will be `tutorial.BookClub.language` which is unique among all apps that could possible have language-objects.

Perhaps the most important for a meta object is it's data address. This section contains information about where to find the data in the object's data source. The data address depends on the query builder used in the data source. For SQL query builders like our `MySqlBuilder` you can use table names here or any valid SQL select statement put in parenthes. Most query builders allow to add more information than merely a textual address - this is where the data source configuration below comes into play. We don't need that for a simple SQL table though. 

You can also explicitly disable reading or writing operations for the object here.

### The `Attributes` tab

Here we can see, that the model builder generated an attribute for every column of the table. Feel free to look around: you can open an attribute by double clicking it or via `Edit` button.

Each attribute, again, has a name and an alias - the latter being the column name for imported attributes. An attribute also has a data adress, which depends on the query builder and defaults to the column name for SQL builders. Similarly to the object's data address we can also use any valid SQL SELECT clause in parenthes. There are also additional data address options as you can see in the `id` column for example. These too are specific to the query builder.

As you can see, the metamodel contains much more information about each attribute than the database schema, so in the vast majority it is a good idea to do some fine tuning after importing the model.

For example, we humans know that the table column `created_by_user_id` contains a link to the workbench's internal user objects, but there is no way to get this information out of the DB schema. Adding relations is the most typical thing to do after a model import along with adding all sorts descriptions and so on.

Let's specify relations for `created_by_user_id` and `modified_by_user_id`:

1. Open the attribute
2. Type `user` in the field "Relation to" and select the user object from the Core app in the dropdown menu
3. Remove the `_id` suffix from the alias of the attribute changing it to `created_by_user`.
4. Change the attribute name to `Created by`
5. Press `Save`

Now we have relations between the object `Language` of the BookClub app and the object `User` of the Core app. Changing the alias and the name of the attributes was only for beautification. However, removing all sorts of `_id` suffixes from the alias of relations is a good practice as it helps follow relation paths a lot as we will see further on. The model builders to it by default too if they can identify a relation automatically!

## 3. Create a base object?

As mentioned above all our tables have a standard set of system columns.

## 4. Import the entire schema

## 5. Check/Add relations