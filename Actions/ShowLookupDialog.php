<?php
namespace exface\Core\Actions;

use exface\Core\Widgets\Dialog;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\DataTypes\WidgetVisibilityDataType;
use exface\Core\CommonLogic\Constants\Icons;
use exface\Core\Widgets\DataLookupDialog;
use exface\Core\Interfaces\Widgets\iHaveFilters;
use exface\Core\Widgets\InputComboTable;
use exface\Core\Interfaces\Widgets\iUseInputWidget;

/**
 * Shows an advanced search dialog allowing the user to search and select data entries.
 * 
 * The seleted UIDs will be sent to the `target_widget_id` overriding it's current value. 
 * Any widget can be used as target. The `multi_select` property of the action controls
 * if the user will be able to select multiple items. By default, this setting will be
 * inherited from the target widget (if it supports multi-select).
 * 
 * If no `widget` is specified by the user, the action will produce an autogenerated
 * `DataLookupDialog` - a search dialog based on default-display settings in the metamodel 
 * of the object being searched. This basically means, that the lookup-dialog will show the 
 * same table as the `InputComboTable` and provide filter over every visible column.
 * 
 * You can customize the lookup dialog by specifying a custom `widget` for the action:
 * 
 * ```
 *  {
 *      "alias": "exface.Core.ShowLookupDialog",
 *      "widget": {
 *          "object_alias": "...",
 *          "widget_type": "DataTable",
 *          "filters": [
 *              {
 *                "attribute_alias": "..."
 *              }
 *          ],
 *          "columns": [
 *              {
 *                "attribute_alias": "..."
 *              }
 *          ]
 *      }
 *  }
 * 
 * ```
 *
 * @author Andrej Kabachnik
 * @author Stefan Leupold
 * @author Thomas Michael
 *        
 */
class ShowLookupDialog extends ShowDialog
{
    private $target_widget_id = null;
    
    private $multi_select = null;

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Actions\ShowWidget::init()
     */
    protected function init()
    {
        parent::init();
        $this->setPrefillWithInputData(false);
        $this->setIcon(Icons::SEARCH);
        
        if ($this->isDefinedInWidget() === true && $this->getWidgetDefinedIn()->is('DialogButton')) {
            $this->getWidgetDefinedIn()->setCloseDialogAfterActionSucceeds(false);
        }
    }
    
    /**
     *
     * {@inheritDoc}
     * @see \exface\Core\Actions\ShowDialog::getDefaultWidgetType()
     */
    public function getDefaultWidgetType() : ?string
    {
        return 'DataLookupDialog';
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Actions\ShowDialog::enhanceDialogWidget()
     */
    protected function enhanceDialogWidget(Dialog $dialog)
    {
        $dialog = parent::enhanceDialogWidget($dialog);
        
        if ($dialog instanceof DataLookupDialog) {
            if ($this->getMultiSelect() !== null) {
                $dialog->setMultiSelect($this->getMultiSelect());
            }
            
            /* @var $data_table \exface\Core\Widgets\DataTable */
            $data_table = $dialog->getDataWidget();
            if ($this->isDefinedInWidget()) {
                $targetWidget = $this->getWidgetDefinedIn();
                if ($targetWidget instanceof iUseInputWidget) {
                    $inputWidget = $targetWidget->getInputWidget();
                    $tableObj = $data_table->getMetaObject();
                    // Inherit filters from calling widget
                    // When inheriting filters, it is important to keept their id space. If this is not
                    // done explicitly, the filter will have a new id space - the one of the lookup
                    // dialog, thus any value links will stop working as they reference the id space of
                    // the table.
                    switch (true) {
                        case ($inputWidget instanceof iHaveFilters && $tableObj->is($inputWidget->getMetaObject())): 
                            foreach($inputWidget->getFilters() as $filter) {
                                // Force the filter to keep its id space - see explanation above the switch()
                                // TODO maybe better to copy the filters somehow?
                                $filter->setIdSpace($filter->getIdSpace());
                                $data_table->addFilter($filter);
                            }
                            break;
                        // In case of InputComboTable, it is very important to inherit all custom
                        // filters as the lookup table should show the same as the dropdown table
                        case ($inputWidget instanceof InputComboTable && $tableObj->is($inputWidget->getTable()->getMetaObject())):
                            foreach($inputWidget->getTable()->getFilters() as $filter) {
                                // Force the filter to keep its id space - see explanation above the switch()
                                // TODO maybe better to copy the filters somehow?
                                $filter->setIdSpace($filter->getIdSpace());
                                $data_table->addFilter($filter);
                            }
                            break;
                        default:
                            break;
                    }
                    // Inherit columns from calling widget
                    $cols = [];
                    switch (true) {
                        // If the input widget is an InputCombotTable, we MUST inherit columns of its
                        // table because the lookup dialog should look the same as the dropdown table.
                        // Additionally, hidden columns MUST be inherited too, because they may be
                        // accessed by data- and value-getters and should be set in the InputComboTable
                        // after an item was looked up.
                        case ($inputWidget instanceof InputComboTable && $tableObj->is($inputWidget->getTable()->getMetaObject())):
                            $cols = $inputWidget->getTable()->getColumns();
                            break;
                        // TODO inherit columns from other types of input widgets? Is it a good idea to
                        // inherit columns from tables? Could be a lot...
                        default:
                            break;
                    }
                    foreach ($cols as $col) {
                        if (! $data_table->getColumnByDataColumnName($col->getDataColumnName())) {
                            $widgetType = $data_table->getColumnDefaultWidgetType();
                            $colUxon = $col->exportUxonObject();
                            $colUxon->setProperty('widget_type', $widgetType);
                            $data_table->addColumn($data_table->createColumnFromUxon($colUxon));
                        }
                    }
                }
            }
            
            // Add the "OK" button
            $btnUxon = new UxonObject([
                'caption' => $this->getWorkbench()->getCoreApp()->getTranslator()->translate("ACTION.SHOWLOOKUPDIALOG.SAVE_BUTTON"),
                'visibility' => WidgetVisibilityDataType::PROMOTED,
                'icon' => Icons::CHECK,
                'action' => [
                    'alias' => 'exface.Core.SendToWidget',
                    'target_widget_id' => $this->getTargetWidgetId()
                ]
            ]);
            $btn = $dialog->createButton($btnUxon)->setInputWidget($data_table);
            $dialog->addButton($btn);
            
            // Press "OK" button automatically on double-click in single-select lookups 
            if ($data_table->getMultiSelect() === false) {
                $singleClickBtnUxon = new UxonObject([
                    'visibility' => WidgetVisibilityDataType::HIDDEN,
                    'bind_to_double_click' => true,
                    'action' => [
                        'alias' => 'exface.Core.CallWidgetFunction',
                        'function' => 'press',
                        'widget_id' => $btn->getId()
                    ]
                ]);
                $data_table->addButton($data_table->createButton($singleClickBtnUxon));
            }
        }
        
        return $dialog;
    }

    /**
     *
     * @return boolean
     */
    public function getTargetWidgetId()
    {
        return $this->target_widget_id;
    }

    /**
     * The id of the widget to receive the selected values.
     *
     * @uxon-property target_widget_id
     * @uxon-type uxon:$..id
     *
     * @param boolean $value            
     * @return \exface\Core\Actions\ShowLookupDialog
     */
    public function setTargetWidgetId($value)
    {
        $this->target_widget_id = $value;
        return $this;
    }
    
    /**
     * Set to TRUE to allow selection of multiple entries in the lookup dialog.
     * 
     * If the lookup dialog is called from an input widget (e.g. `InputComboTable`) this setting
     * is inherited from that input. Otherwise it is `false` by default.
     * 
     * @uxon-property multi_select
     * @uxon-type boolean
     * @uxon-default false
     * 
     * @param bool $trueOrFalse
     * @return ShowLookupDialog
     */
    public function setMultiSelect(bool $trueOrFalse) : ShowLookupDialog
    {
        $this->multi_select = $trueOrFalse;
        return $this;
    }
    
    /**
     * 
     * @return bool|NULL
     */
    protected function getMultiSelect() : ?bool
    {
        return $this->multi_select;
    }
}