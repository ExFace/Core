<?php
namespace exface\Core\Widgets;

use exface\Core\Interfaces\Widgets\iHaveButtons;
use exface\Core\Interfaces\Widgets\iHaveContextualHelp;
use exface\Core\Widgets\Traits\iHaveButtonsAndToolbarsTrait;
use exface\Core\Widgets\Traits\iHaveContextualHelpTrait;
use exface\Core\Interfaces\Widgets\iHaveToolbars;
use exface\Core\DataTypes\AggregatorFunctionsDataType;
use exface\Core\Interfaces\Widgets\iShowMessageList;
use exface\Core\Factories\WidgetFactory;
use exface\Core\Interfaces\Widgets\iContainOtherWidgets;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Interfaces\Widgets\iShowSingleAttribute;
use exface\Core\Interfaces\DataSheets\DataSheetInterface;
use exface\Core\Interfaces\Model\MetaAttributeInterface;

/**
 * A Form is a Panel with buttons.
 * 
 * Forms and their derivatives provide input data for actions.
 *
 * While having similar purpose as HTML forms, ExFace forms are not the same! They can be nested, they may include tabs,
 * optional panels with lazy loading, etc. Thus, in most HTML-facades the form widget will not be mapped to an HTML
 * form, but rather to some container element (e.g. <div>), while fetching data from the form will need to be custom
 * implemented (i.e. with JavaScript).
 *
 * @author Andrej Kabachnik
 *        
 */
class Form extends Panel implements iHaveButtons, iHaveToolbars, iShowMessageList, iHaveContextualHelp
{
    use iHaveButtonsAndToolbarsTrait;
    use iHaveContextualHelpTrait {
        getHideHelpButton as getHideHelpButtonViaTrait;
    }
    
    private $messageList = null;

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Widgets\Container::getChildren()
     */
    public function getChildren() : \Iterator
    {
        foreach (parent::getChildren() as $child) {
            yield $child;
        }
        
        foreach ($this->getToolbars() as $tb) {
            yield $tb;
        }
        
        // Add the help button, so pages will be able to find it when dealing with the ShowHelpDialog action.
        // IMPORTANT: Add the help button to the children only if it is not hidden. This is needed to hide the button in
        // help widgets themselves, because otherwise they would produce their own help widgets, with - in turn - even
        // more help widgets, resulting in an infinite loop.
        if (! $this->getHideHelpButton()) {
            yield $this->getHelpButton();
        }
    }
    
    public function getToolbarWidgetType(){
        return 'FormToolbar';
    }
    
    /**
     * Adds hidden inputs for system attributes etc. required for the action of the given button widget.
     * 
     * @param Button $button
     * @return Form
     */
    public function addRequiredWidgets(Button $button)
    {
        // If the button has an action, that is supposed to modify data, we need to make sure, that the panel
        // contains alls system attributes of the base object, because they may be needed by the business logic
        if ($action = $button->getAction()) {
            if ($action->getMetaObject()->is($this->getMetaObject()) && ($action->implementsInterface('iModifyData') || $action->implementsInterface('iModifyContext'))) {
                /* @var $attr \exface\Core\Interfaces\Model\MetaAttributeInterface */
                foreach ($this->getMetaObject()->getAttributes()->getSystem() as $attr) {
                    if (count($this->findChildrenByAttribute($attr)) === 0) {
                        $widget = $this->getPage()->createWidget('InputHidden', $this);
                        $widget->setAttributeAlias($attr->getAlias());
                        if ($attr->isUidForObject()) {
                            $widget->setAggregator(AggregatorFunctionsDataType::LIST_ALL($this->getWorkbench()));
                        } else {
                            $widget->setAggregator($attr->getDefaultAggregateFunction());
                        }
                        // Put the widget at the beginning of the form! This is important as the form itself might
                        // contain other (explicitly defined) widgets for the same attributes, which are more important
                        // (because explicitly defined). In all sorts of data extraction processes, the last widget
                        // wins, so we need to make sure, autogenerated ones are first in line. A good example is the
                        // quick-edit dialog for attributes in the default object editor: the dialog has autogenerated
                        // system fields due to the save-button, but contains an editable table, which in-turn has
                        // system fields for each row. When the data is extracted, the table row value overwrite the
                        // values of the hidden fields in the dialog because the table is placed after them.
                        $this->addWidget($widget, 0);
                    }
                }
            }
        }
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Widgets\iShowMessageList::getMessageList()
     */
    public function getMessageList() : MessageList
    {
        if ($this->messageList === null) {
            $this->messageList = WidgetFactory::create($this->getPage(), 'MessageList', $this);
        }
        return $this->messageList;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Widgets\iShowMessageList::hasMessages()
     */
    public function hasMessages() : bool
    {
        if ($this->messageList !== null && $this->getMessageList()->isEmpty() === false) {
            return true;
        } 
        
        return false;
    }
    
    /**
     * Array of widgets to be placed in the form (inputs or any other kind of widget).
     * 
     * @uxon-property widgets
     * @uxon-type \exface\Core\Widgets\Input[]|\exface\Core\Widgets\AbstractWidget[]
     * @uxon-template [{"attribute_alias": ""}]
     * 
     * @see \exface\Core\Widgets\Container::setWidgets()
     */
    public function setWidgets($widget_or_uxon_array)
    {
        return parent::setWidgets($widget_or_uxon_array);
    }
    
    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\Widgets\iHaveContextualHelp::getHelpWidget()
     */
    public function getHelpWidget(iContainOtherWidgets $help_container) : iContainOtherWidgets
    {
        $table = $this->getHelpTable($help_container);
        $help_container->addWidget($table);
        
        
        $data_sheet = $this->getHelpData($this->getWidgets(), DataSheetFactory::createFromObject($table->getMetaObject()));
        
        if ($data_sheet->isEmpty() === true) {
            $data_sheet->addRow([
                'TITLE' => '',
                'DESCRIPTION' => $this->getWorkbench()->getCoreApp()->getTranslator()->translate('ACTION.SHOWHELPDIALOG.NO_HELP'),
                'GROUP' => ''
            ]);
        }
        
        // Mark the data sheet is fresh here - even if it is empty! - because
        // otherwise further code might attempt to load data from the unreadable
        // help meta object.
        $data_sheet->setFresh(true);
        
        $table->prefill($data_sheet);
        
        return $help_container;
    }
    
    /**
     * Adds information about each widget in the array to the given sheet.
     *
     * @param array $widgets
     * @param DataSheetInterface $dataSheet
     * @param string $groupName
     * @return DataSheetInterface
     */
    protected function getHelpData(array $widgets, DataSheetInterface $dataSheet, string $groupName = null) : DataSheetInterface
    {
        foreach ($widgets as $widget) {
            if ($widget->isHidden()) {
                continue;
            }
            
            if ($widget instanceof iContainOtherWidgets) {
                if ($widget->getCaption()) {
                    $groupName = $widget->getCaption();
                }
                $dataSheet = $this->getHelpData($widget->getWidgets(), $dataSheet, $groupName);
            } elseif ($widget->getCaption()) {
                $row = [
                    'TITLE' => $widget->getCaption(),
                    'GROUP' => $groupName ?? ''
                ];
                if ($widget instanceof iShowSingleAttribute && $attr = $widget->getAttribute()) {
                    $row = array_merge($row, $this->getHelpRowFromAttribute($attr));
                }
                $dataSheet->addRow($row);
            }
        }
        return $dataSheet;
    }
    
    /**
     * Returns a row (assotiative array) for a data sheet with exface.Core.USER_HELP_ELEMENT filled with information about
     * the given attribute.
     * The inforation is derived from the attributes meta model.
     *
     * @param MetaAttributeInterface $attr
     * @return string[]
     */
    protected function getHelpRowFromAttribute(MetaAttributeInterface $attr)
    {
        $row = array();
        $row['DESCRIPTION'] = $attr->getShortDescription() ? rtrim(trim($attr->getShortDescription()), ".") . '.' : '';
        
        if (! $attr->getRelationPath()->isEmpty()) {
            $row['DESCRIPTION'] .= $attr->getObject()->getShortDescription() ? ' ' . rtrim($attr->getObject()->getShortDescription(), ".") . '.' : '';
        }
        return $row;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Widgets\iHaveContextualHelp::getHideHelpButton()
     */
    public function getHideHelpButton($default = false) : ?bool
    {
        return $this->getHideHelpButtonViaTrait(null) ?? $this->hasParent() === true;
    }
}