<?php
namespace exface\Core\Widgets;

use exface\Core\Interfaces\Widgets\iHaveButtons;
use exface\Core\Widgets\Traits\iHaveButtonsAndToolbarsTrait;
use exface\Core\Interfaces\Widgets\iHaveToolbars;
use exface\Core\DataTypes\AggregatorFunctionsDataType;
use exface\Core\Interfaces\Widgets\iShowMessageList;
use exface\Core\Factories\WidgetFactory;

/**
 * A Form is a Panel with buttons.
 * Forms and their derivatives provide input data for actions.
 *
 * While having similar purpose as HTML forms, ExFace forms are not the same! They can be nested, they may include tabs,
 * optional panels with lazy loading, etc. Thus, in most HTML-templates the form widget will not be mapped to an HTML
 * form, but rather to some container element (e.g. <div>), while fetching data from the form will need to be custom
 * implemented (i.e. with JavaScript).
 *
 * @author Andrej Kabachnik
 *        
 */
class Form extends Panel implements iHaveButtons, iHaveToolbars, iShowMessageList
{
    use iHaveButtonsAndToolbarsTrait;
    
    private $messageList = null;

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Widgets\Container::getChildren()
     */
    public function getChildren() : \Iterator
    {
        foreach (parent::getChildren() as $child) {
            yield $child;
        }
        
        foreach ($this->getToolbars() as $tb) {
            yield $tb;
        }
    }
    
    public function getToolbarWidgetType(){
        return 'FormToolbar';
    }
    
    /**
     * Adds hidden inputs for system attributes etc. required for the action of the given button widget.
     * 
     * @param Button $button
     * @return Form
     */
    public function addRequiredWidgets(Button $button)
    {
        // If the button has an action, that is supposed to modify data, we need to make sure, that the panel
        // contains alls system attributes of the base object, because they may be needed by the business logic
        if ($action = $button->getAction()) {
            if ($action->getMetaObject()->is($this->getMetaObject()) && ($action->implementsInterface('iModifyData') || $action->implementsInterface('iModifyContext'))) {
                /* @var $attr \exface\Core\Interfaces\Model\MetaAttributeInterface */
                foreach ($this->getMetaObject()->getAttributes()->getSystem() as $attr) {
                    if (count($this->findChildrenByAttribute($attr)) === 0) {
                        $widget = $this->getPage()->createWidget('InputHidden', $this);
                        $widget->setAttributeAlias($attr->getAlias());
                        if ($attr->isUidForObject()) {
                            $widget->setAggregator(AggregatorFunctionsDataType::LIST_ALL($this->getWorkbench()));
                        } else {
                            $widget->setAggregator($attr->getDefaultAggregateFunction());
                        }
                        // Put the widget at the beginning of the form! This is important as the form itself might
                        // contain other (explicitly defined) widgets for the same attributes, which are more important
                        // (because explicitly defined). In all sorts of data extraction processes, the last widget
                        // wins, so we need to make sure, autogenerated ones are first in line. A good example is the
                        // quick-edit dialog for attributes in the default object editor: the dialog has autogenerated
                        // system fields due to the save-button, but contains an editable table, which in-turn has
                        // system fields for each row. When the data is extracted, the table row value overwrite the
                        // values of the hidden fields in the dialog because the table is placed after them.
                        $this->addWidget($widget, 0);
                    }
                }
            }
        }
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Widgets\iShowMessageList::getMessageList()
     */
    public function getMessageList() : MessageList
    {
        if ($this->messageList === null) {
            $this->messageList = WidgetFactory::create($this->getPage(), 'MessageList', $this);
        }
        return $this->messageList;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\Widgets\iShowMessageList::hasMessages()
     */
    public function hasMessages() : bool
    {
        if ($this->messageList !== null && $this->getMessageList()->isEmpty() === false) {
            return true;
        } 
        
        return false;
    }
}
?>