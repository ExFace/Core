<?php
namespace exface\Core\Widgets;

use exface\Core\Interfaces\Widgets\iContainOtherWidgets;
use exface\Core\Factories\WidgetFactory;
use exface\Core\DataTypes\AggregatorFunctionsDataType;
use exface\Core\Interfaces\Widgets\iHaveButtons;

/**
 * Special toolbar for Form widgets (by default every toolbar in a Form is a FormToolbar).
 * 
 * Technically, the difference between `FormToolbar` and a generic `Tooblar` is that the
 * former double checks if it's input widget (i.e. the form) has all system attributes
 * needed for each of it's button's actions. If not, hidden fields with the corresponding
 * attributes are added automatically. 
 * 
 * @method Form getInputWidget()
 * 
 * @author Andrej Kabachnik
 *
 */
class FormToolbar extends Toolbar
{
    /**
     * 
     * @return \exface\Core\Widgets\Form
     */
    public function getFormWidget()
    {
        return $this->getInputWidget();
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Widgets\Toolbar::addButton()
     */
    public function addButton(Button $button_widget, $index = null)
    {
        parent::addButton($button_widget, $index);
        $this->addSystemAttributeWidgets($this->getFormWidget(), $button_widget);
        return $this;
    }
    
    /**
     * Array of button widgets to be placed in the toolbar.
     * 
     * @uxon-property buttons
     * @uxon-type \exface\Core\Widgets\Button[]
     * @uxon-template [{"action_alias": ""}]
     * 
     * Since buttons are not neccessarily added using FormToolbar::addButton(), but can be
     * added to enclosed button groups directly, the check for required widgets in the form
     * must be explicitly performed here for every button.
     * 
     * IDEA Auto-adding system widgets required for a button only works if the button is
     * added to the form toolbar or the form directly, but not if it is added to a button
     * goup enclosed. Perhaps there is some way to automate this too?
     * 
     * @see \exface\Core\Widgets\Toolbar::setButtons()
     */
    public function setButtons($buttons)
    {
        parent::setButtons($buttons);
        $form = $this->getFormWidget();
        foreach ($this->getButtons() as $btn) {
            $this->addSystemAttributeWidgets($form, $btn);
        }
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Widgets\Toolbar::getButtonWidgetType()
     */
    public function getButtonWidgetType()
    {
        if ($this->getParent() instanceof iHaveButtons) {
            return $this->getParent()->getButtonWidgetType();
        }
        return 'Button';
    }
    
    /**
     * Adds hidden inputs for system attributes etc. required for the action of the given button widget.
     *
     * @param Button $button
     * @return Form
     */
    protected function addSystemAttributeWidgets(iContainOtherWidgets $container, Button $button) : FormToolbar
    {
        // If the button has an action, that is supposed to modify data, we need to make sure, that the panel
        // contains alls system attributes of the base object, because they may be needed by the business logic
        if ($action = $button->getAction()) {
            $obj = $container->getMetaObject();
            $workbench = $this->getWorkbench();
            $page = $container->getPage();
            if ($action->getMetaObject()->is($obj) && ($action->implementsInterface('iModifyData') || $action->implementsInterface('iModifyContext'))) {
                /* @var $attr \exface\Core\Interfaces\Model\MetaAttributeInterface */
                foreach ($obj->getAttributes()->getSystem() as $attr) {
                    if (count($container->findChildrenByAttribute($attr)) === 0) {
                        $widget = WidgetFactory::create($page, 'InputHidden', $container);
                        $widget->setAttributeAlias($attr->getAlias());
                        $widget->setIgnoreDefaultValue(true);
                        if ($attr->isUidForObject()) {
                            $widget->setAggregator(AggregatorFunctionsDataType::LIST_ALL($workbench));
                        } else {
                            $widget->setAggregator($attr->getDefaultAggregateFunction());
                        }
                        // Put the widget at the beginning of the form! This is important as the form itself might
                        // contain other (explicitly defined) widgets for the same attributes, which are more important
                        // (because explicitly defined). In all sorts of data extraction processes, the last widget
                        // wins, so we need to make sure, autogenerated ones are first in line. A good example is the
                        // quick-edit dialog for attributes in the default object editor: the dialog has autogenerated
                        // system fields due to the save-button, but contains an editable table, which in-turn has
                        // system fields for each row. When the data is extracted, the table row value overwrite the
                        // values of the hidden fields in the dialog because the table is placed after them.
                        $container->addWidget($widget, 0);
                    }
                }
            }
        }
        return $this;
    }
}
