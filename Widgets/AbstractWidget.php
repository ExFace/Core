<?php
namespace exface\Core\Widgets;

use exface\Core\CommonLogic\Model\Expression;
use exface\Core\Interfaces\DataSheets\DataSheetInterface;
use exface\Core\Interfaces\Widgets\iShowSingleAttribute;
use exface\Core\Interfaces\WidgetInterface;
use exface\Core\Interfaces\Model\MetaObjectInterface;
use exface\Core\Factories\WidgetDimensionFactory;
use exface\Core\Interfaces\Model\UiPageInterface;
use exface\Core\CommonLogic\Model\RelationPath;
use exface\Core\Factories\RelationPathFactory;
use exface\Core\Exceptions\Widgets\WidgetIdConflictError;
use exface\Core\Exceptions\Widgets\WidgetPropertyInvalidValueError;
use exface\Core\Exceptions\Widgets\WidgetConfigurationError;
use exface\Core\Exceptions\Widgets\WidgetPropertyUnknownError;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\DataTypes\BooleanDataType;
use exface\Core\CommonLogic\Traits\ImportUxonObjectTrait;
use exface\Core\Exceptions\UxonMapError;
use exface\Core\Exceptions\Widgets\WidgetHasNoMetaObjectError;
use exface\Core\Factories\WidgetFactory;
use exface\Core\Interfaces\Model\ExpressionInterface;
use exface\Core\CommonLogic\Translation;
use exface\Core\Interfaces\Selectors\AliasSelectorInterface;
use exface\Core\Factories\ExpressionFactory;
use exface\Core\Events\Widget\OnBeforePrefillEvent;
use exface\Core\Events\Widget\OnPrefillEvent;
use exface\Core\Interfaces\Events\EventInterface;
use exface\Core\Interfaces\Widgets\WidgetLinkInterface;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Widgets\Traits\iHaveCaptionTrait;
use exface\Core\Uxon\WidgetSchema;
use exface\Core\Widgets\Traits\iHaveVisibilityTrait;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Widgets\Parts\ConditionalProperty;
use exface\Core\Interfaces\Facades\FacadeInterface;
use exface\Core\Factories\SelectorFactory;

/**
 * Basic ExFace widget
 *
 * @author Andrej Kabachnik
 *        
 */
abstract class AbstractWidget implements WidgetInterface
{
    use ImportUxonObjectTrait {
		importUxonObject as importUxonObjectDefault;
	}
	use iHaveCaptionTrait;
	use iHaveVisibilityTrait;

    private $id_specified = null;

    private $id_autogenerated = null;

    private $hint = null;

    private $widget_type = null;
    
    private $meta_object = null;

    private $object_alias = null;

    private $object_relation_path_to_parent = null;

    private $object_relation_path_from_parent = null;

    private $object_qualified_alias = null;

    private $value = null;

    private $disabled = NULL;

    private $width = null;

    private $height = null;

    private $visibility = null;

    /** @var \exface\Core\Widgets\AbstractWidget the parent widget */
    private $parent = null;

    private $ui = null;

    private $data_connection_alias_specified_by_user = NULL;

    private $prefill_data = null;

    private $uxon_original = null;

    private $page = null;

    private $do_not_prefill = false;

    private $id_space = null;
    
    private $disabled_if = null;

    private $parentByType = [];
    
    private $facadeOptions = null;

    /**
     *
     * @deprecated use WidgetFactory::create() instead!
     * @param UiPageInterface $page            
     * @param WidgetInterface $parent_widget            
     * @param string $fixed_widget_id            
     */
    function __construct(UiPageInterface $page, WidgetInterface $parent_widget = null, $fixed_widget_id = null)
    {
        $this->page = $page;
        $this->widget_type = static::getWidgetTypeFromClass(get_class($this));
        // Set the parent widget if known
        if ($parent_widget) {
            $this->setParent($parent_widget);
        }
        
        if ($fixed_widget_id) {
            $this->setIdSpecified($fixed_widget_id);
        }
        
        // Add widget to the page. It will now get an autogenerated id
        $page->addWidget($this);
        $this->init();
    }

    public static function getWidgetTypeFromClass($class_name)
    {
        return substr($class_name, (strrpos($class_name, '\\') + 1));
    }

    /**
     * This method is called every time a widget is instantiated an can be used as a hook for additional initializing logics.
     *
     * @return void
     */
    protected function init()
    {}

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::importUxonObject()
     */
    public function importUxonObject(UxonObject $uxon)
    {
        // Save the original UXON description
        $this->uxon_original = $uxon->copy();
        
        // Now do the actual importing
        // First look for an object alias. It must be assigned before the rest because many other properties depend on having the right object
        if ($uxon->hasProperty('object_alias')) {
            $this->setObjectAlias($uxon->getProperty('object_alias'));
        }
        // Same goes for id and id_space
        if ($uxon->hasProperty('id_space')) {
            $this->setIdSpace($uxon->getProperty('id_space'));
            $uxon->unsetProperty('id_space');
        }
        if ($uxon->hasProperty('id')) {
            $this->setId($uxon->getProperty('id'));
            $uxon->unsetProperty('id');
        }
        
        try {
            return $this->importUxonObjectDefault($uxon);
        } catch (UxonMapError $e) {
            throw new WidgetPropertyUnknownError($this, 'Unknown UXON property found for widget "' . $this->getWidgetType() . '": ' . $e->getMessage(), '6UNTXJE', $e);
        }
        return;
    }
    
    /**
     *
     * {@inheritdoc}
     * @see \exface\Core\Interfaces\iCanBeConvertedToUxon::getUxonSchemaClass()
     */
    public static function getUxonSchemaClass() : ?string
    {
        return WidgetSchema::class;
    }

    public function exportUxonObject()
    {
        $uxon = $this->exportUxonObjectOriginal();
        
        if ($this->getIdSpecified()) {
            $uxon->setProperty('id', $this->getId());
        }
        $uxon->setProperty('widget_type', $this->getWidgetType());
        $uxon->setProperty('object_alias', $this->getMetaObject()->getAliasWithNamespace());
        
        $this->exportUxonObjectAddCaptionPoperties($uxon);
        
        if ($this->disabled !== null) {
            $uxon->setProperty('disabled', $this->isDisabled());
        }
        if ($this->disabled_if !== null) {
            $uxon->setProperty('disabled_if', $this->getDisabledIf()->exportUxonObject());
        }
        
        if ($this->hint !== null) {
            $uxon->setProperty('hint', $this->getHint());
        }
        if ($this->getValue() !== null) {
            $uxon->setProperty('value', $this->getValue());
        }
        if ($this->getVisibility() !== null) {
            $uxon->setProperty('visibility', $this->getVisibility());
        }
        if (! $this->getWidth()->isUndefined()) {
            $uxon->setProperty('width', $this->getWidth()->toString());
        }
        if (! $this->getHeight()->isUndefined()) {
            $uxon->setProperty('height', $this->getHeight()->toString());
        }
        return $uxon;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::exportUxonObjectOriginal()
     */
    public function exportUxonObjectOriginal()
    {
        if ($this->uxon_original instanceof UxonObject) {
            return $this->uxon_original;
        } else {
            return new UxonObject();
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::prefill()
     */
    public final function prefill(DataSheetInterface $data_sheet)
    {
        if ($this->getDoNotPrefill()) {
            return;
        }
        $this->getWorkbench()->eventManager()->dispatch(new OnBeforePrefillEvent($this, $data_sheet));
        $this->setPrefillData($data_sheet);
        $this->doPrefill($data_sheet);
        $this->getWorkbench()->eventManager()->dispatch(new OnPrefillEvent($this, $data_sheet));
        return;
    }
    
    /**
     * Prefills the widget using values from the given data sheet.
     * 
     * Override this method for custom prefill logic of a widget. By default it
     * will not do anything at all. 
     * 
     * IMPORTANT: don't forget to dispatch a `OnPrefillChangePropertyEvent` every
     * time you change a widget from your prefill logic!
     * 
     * @param DataSheetInterface $data_sheet
     * 
     * @triggers exface\Core\Events\Widget\OnPrefillChangePropertyEvent
     * 
     * @return void
     */
    protected function doPrefill(DataSheetInterface $data_sheet)
    {
        return;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::prepareDataSheetToRead()
     */
    public function prepareDataSheetToRead(DataSheetInterface $data_sheet = null)
    {
        if (is_null($data_sheet)) {
            $data_sheet = DataSheetFactory::createFromObject($this->getMetaObject());
        }
        return $data_sheet;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::prepareDataSheetToPrefill()
     */
    public function prepareDataSheetToPrefill(DataSheetInterface $data_sheet = null) : DataSheetInterface
    {
        if (is_null($data_sheet)) {
            $data_sheet = DataSheetFactory::createFromObject($this->getMetaObject());
        }
        return $data_sheet;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::isPrefillable()
     */
    public function isPrefillable()
    {
        return ! $this->getDoNotPrefill();
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::isPrefilled()
     */
    public function isPrefilled() : bool
    {
        return $this->prefill_data !== null;
    }

    /**
     * Sets the widget type (= widget selector).
     * 
     * In contrast to the widget selector, the widget type has only two syntax variants:
     * - the name of the widget (e.g. `DataTable`) for core widgets
     * - a namespaced widget alias for custom widgets from other apps (i.e. `my.App.MyCustomWidget`).
     *
     * @uxon-property widget_type
     * @uxon-type metamodel:widget
     *
     * @param string $selectorString    
     * @return WidgetInterface        
     */
    protected function setWidgetType($selectorString) : WidgetInterface
    {
        if ($selectorString) {
            if (stripos($selectorString, 'exface.Core.') === 0) {
                $this->widget_type = str_replace('exface.Core.', '', $selectorString);
            } elseif (strpos($selectorString, '/') !== false || strpos($selectorString, '\\') !== false) {
                throw new WidgetPropertyInvalidValueError('Invalid widget type "' . $selectorString . '": classname and filepath selectors not yet supported - please use alias!');
            } else {
                $this->widget_type = $selectorString;
            }
        }
        return $this;
    }
    
    /**
     * Explicitly specifies the ID of the widget.
     * The ID must be unique on every page containing the widget and can be used in widget links
     *
     * @uxon-property id
     * @uxon-type string
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setId()
     */
    function setId($id)
    {
        return $this->setIdSpecified($id);
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::hasChildren()
     */
    public function hasChildren() : bool
    {
        foreach ($this->getChildren() as $child) {
            return true;
        }
        return false;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getChildren()
     */
    public function getChildren() : \Iterator
    {
        return new \EmptyIterator();
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getChildrenRecursive()
     */
    public function getChildrenRecursive() : \Iterator
    {
        // Use a generator here because widgets with lot's of children (e.g. large editor dialogs)
        // will need to instantiate ALL their children first if we use an array. This is useless,
        // since in many cases getChildrenRecursive is used to look for some widgets in shallow
        // recursion levels.
        // For the same reason first yield the direct children an than yield children's children
        // - this makes the method return children by levels and not by recursion path.
        foreach ($this->getChildren() as $child) {
            yield $child;
        }
        
        foreach ($this->getChildren() as $child) {
            yield from $child->getChildrenRecursive();
            // Excplicitly continue - otherwise the foreach will break after the first yield from
            continue;
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getMetaObject()
     */
    function getMetaObject()
    {
        if (is_null($this->meta_object)) {
            if ($this->getObjectQualifiedAlias()) {
                $obj = $this->getWorkbench()->model()->getObject($this->getObjectQualifiedAlias());
            } elseif ($this->getParent()) {
                $obj = $this->getParent()->getMetaObject();
            } else {
                throw new WidgetHasNoMetaObjectError($this, 'A widget must have either an object_id, an object_alias or a parent widget with an object reference!');
            }
            $this->setMetaObject($obj);
        }
        return $this->meta_object;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setMetaObject()
     */
    function setMetaObject(MetaObjectInterface $object)
    {
        $this->meta_object = $object;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getId()
     */
    public function getId() : ?string
    {
        if ($id = $this->getIdSpecified()) {
            return $id;
        }
        return $this->getIdAutogenerated();
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getIdSpecified()
     */
    public function getIdSpecified(bool $includeIdSpace = true) : ?string
    {
        if ($includeIdSpace === false) {
            $withNs = $this->id_specified ?? '';
            return StringDataType::substringAfter($withNs, $this->getIdSpace() . $this->getPage()->getWidgetIdSpaceSeparator(), $withNs);
        }
        return $this->id_specified;
    }

    public function setIdSpecified($value)
    {
        $value = ($this->getIdSpace() ? $this->getIdSpace() . $this->getPage()->getWidgetIdSpaceSeparator() : '') . $value;
        
        // Don't do anything, if the id's are identical
        if ($this->getId() === $value) {
            return $this;
        }
        
        // Just set the id_specified property if there is no id at all at this point
        if (! $this->getId()) {
            $this->id_specified = $value;
            return $this;
        }
        
        $old_id = $this->id_specified;
        
        try {
            $this->id_specified = $value;
            $this->getPage()->addWidget($this);
            if ($old_id) {
                $this->getPage()->removeWidgetById($this->id_specified);
            }
        } catch (WidgetIdConflictError $e) {
            $this->id_specified = $old_id;
            throw $e;
        }
        
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getIdAutogenerated()
     */
    public function getIdAutogenerated() : ?string
    {
        return $this->id_autogenerated;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::setIdAutogenerated()
     */
    public function setIdAutogenerated($value)
    {
        $this->id_autogenerated = $value;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getIdSpace()
     */
    public function getIdSpace()
    {
        if ($this->id_space === null) {
            if ($this->hasParent() && $parent_id_space = $this->getParent()->getIdSpace()) {
                $this->id_space = $parent_id_space;
            } else {
                return '';
            }
        }
        return $this->id_space;
    }

    /**
     * Separates the children of the widget into a separate id space within the page.
     *
     * Multiple widgets with the same id can coexist in a page if the are placed in separate id spaces.
     * This is usefull to reuse complex widgets with live references multiple times on one page. For
     * example, if you have created a complex editor dialog and want to extend from it to create separate
     * buttons for creating a new object and editing one, you can specify a custom id space for each
     * of the buttons - this way, the live references within the button's action will work although
     * the ids specified in them are not unique on the page anymore.
     *
     * @uxon-property id_space
     * @uxon-type string
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setIdSpace()
     */
    public function setIdSpace($value)
    {
        $id_space_old = $this->id_space;
        $this->id_space = $value;
        // If the id space changes and the widget has an explicit id, make sure the id is reregistered.
        // This will transfer the id into the new id space.
        if ($value != $id_space_old && $this->getIdSpecified()) {
            $this->setId($this->getIdSpecified());
        }
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getWidgetType()
     */
    function getWidgetType()
    {
        return $this->widget_type;
    }

    /**
     * TODO Move to iHaveValue-Widgets or trait
     *
     * @return string|NULL
     */
    public function getValue()
    {
        if ($this->getValueExpression()) {
            return $this->getValueExpression()->toString();
        }
        return null;
    }

    /**
     * TODO Move to iHaveValue-Widgets or trait
     *
     * @return ExpressionInterface|NULL
     */
    public function getValueExpression()
    {
        return $this->value;
    }

    /**
     *
     * @return WidgetLinkInterface|NULL
     */
    public function getValueWidgetLink()
    {
        $link = null;
        $expr = $this->getValueExpression();
        if ($expr && $expr->isReference()) {
            $link = $expr->getWidgetLink($this);
        }
        return $link;
    }

    /**
     * Explicitly sets the value of the widget
     *
     * @uxon-property value
     * @uxon-type string|model:formula
     *
     * TODO Move to iHaveValue-Widgets or trait
     *
     * @param ExpressionInterface|string $expression_or_string            
     */
    public function setValue($expression_or_string)
    {
        if ($expression_or_string instanceof expression) {
            $this->value = $expression_or_string;
        } else {
            // FIXME #expression-syntax Handling of value-expressions seems really buggy. On the one hand, 
            // passing a string value should result in the widget showing this exact value - no matter if
            // it included quotes or not. On the other hand, a non-quoted string would result in an Expression
            // of UNKNOWN type, which is not static, thus widgets would not show anything unless prefilled. If
            // we add quotes to signal, that this is a static string, they will show up in the widget even
            // if the user did not want them. For example, many doPrefill() methods would just result in
            // setValue($prefillValue) - no quotes, no checks for data type, althoug this clearly is a static
            // value. Finally, if the user sets the value in UXON, the general expression syntax suggests to use 
            // quotes for strings, but these would show up in the UI. 
            // Here is a temporary solution for the problem: tell the ExpressionFactory to treat unquoted strings
            // as strings in this case explicitly.
            $expr = ExpressionFactory::createFromString($this->getWorkbench(), $expression_or_string, $this->getMetaObject(), true);
            $this->value = $expr;
            // If the value is a widget link, call the getter to make sure the link is instantiated
            // thus firing OnWidgetLinkedEvent. If not done here, the event will be only fired
            // when some other code calls $expr->getWidgetLink(), which may happen too late for
            // possible event handlers!
            if ($expr->isReference()) {
                $this->getValueWidgetLink();
            }
        }
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isDisabled()
     */
    public function isDisabled()
    {
        return $this->disabled;
    }

    /**
     * Set to TRUE to disable the widget.
     * Disabled widgets cannot accept input or interact with the user in any other way.
     *
     * @uxon-property disabled
     * @uxon-type boolean
     * @uxon-default false
     * 
     * @see \exface\Core\Interfaces\WidgetInterface::setDisabled()
     */
    public function setDisabled($value)
    {
        $this->disabled = \exface\Core\DataTypes\BooleanDataType::cast($value);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getWidth()
     */
    public function getWidth()
    {
        if (! $this->width) {
            $exface = $this->getWorkbench();
            $this->width = WidgetDimensionFactory::createEmpty($exface);
        }
        return $this->width;
    }

    /**
     * Sets the width of the widget.
     * Set to `1` for default widget width in a facade or `max` for maximum width possible.
     *
     * The width can be specified either in
     * - facade-specific relative units (e.g. `width: 2` makes the widget twice as wide
     * as the default width of a widget in the current facade)
     * - percent (e.g. `width: 50%` will make the widget take up half the available space)
     * - any other facade-compatible units (e.g. `width: 200px` will work in CSS-based facades)
     *
     * @uxon-property width
     * @uxon-type string
     *
     * {@inheritdoc}
     * @see \exface\Core\Interfaces\WidgetInterface::setWidth()
     */
    public function setWidth($value)
    {
        $exface = $this->getWorkbench();
        $this->width = WidgetDimensionFactory::createFromAnything($exface, $value);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getHeight()
     */
    public function getHeight()
    {
        if (! $this->height) {
            $exface = $this->getWorkbench();
            $this->height = WidgetDimensionFactory::createEmpty($exface);
        }
        return $this->height;
    }

    /**
     * Sets the height of the widget.
     * Set to `1` for default widget height in a facade or `max` for maximum height possible.
     *
     * The height can be specified either in
     * - facade-specific relative units (e.g. `height: 2` makes the widget twice as high
     * as the default width of a widget in the current facade)
     * - percent (e.g. `height: 50%` will make the widget take up half the available space)
     * - any other facade-compatible units (e.g. `height: 200px` will work in CSS-based facades)
     *
     * @uxon-property height
     * @uxon-type string
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setHeight()
     */
    public function setHeight($value)
    {
        $exface = $this->getWorkbench();
        $this->height = WidgetDimensionFactory::createFromAnything($exface, $value);
        return $this;
    }

    /**
     * Returns the full alias of the main meta object (prefixed by the app namespace - e.g.
     * CRM.CUSTOMER)
     */
    public function getObjectQualifiedAlias()
    {
        return $this->object_qualified_alias;
    }

    /**
     * Sets the alias of the main object of the widget.
     * Use qualified aliases (with namespace)!
     *
     * @uxon-property object_alias
     * @uxon-type metamodel:object
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setObjectAlias()
     */
    public function setObjectAlias($full_or_object_alias)
    {
        // If it's a fully qualified alias, use it directly
        if ($ns = $this->getWorkbench()->model()->getNamespaceFromQualifiedAlias($full_or_object_alias)) {
            $this->object_qualified_alias = $full_or_object_alias;
            $this->object_alias = $this->getWorkbench()->model()->getObjectAliasFromQualifiedAlias($full_or_object_alias);
        } else {
            // ... if the namespace is missing, get it from the app of the parent object
            if ($this->getParent()) {
                $ns = $this->getParent()->getMetaObject()->getNamespace();
            }
            
            if (! $ns) {
                throw new WidgetConfigurationError($this, 'Cannot set object_alias property for widget "' . $this->getId() . '": neither a namespace is specified, nor is there a parent widget to take it from!', '6UOD4TW');
            }
            $this->object_alias = $full_or_object_alias;
            $this->object_qualified_alias = $ns . AliasSelectorInterface::ALIAS_NAMESPACE_DELIMITER . $this->object_alias;
        }
        // IMPORTANT: unset the meta_object of this class, because it may already have been initialized previously.
        unset($this->meta_object);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getObjectRelationPathFromParent()
     */
    public function getObjectRelationPathFromParent()
    {
        if (is_null($this->object_relation_path_from_parent)) {
            // If there is no relation to the parent set yet, see if there is a parent.
            // If not, do not do anything - maybe there will be some parent when the method is called the next time
            if ($this->getParent()) {
                // If there is no relation path yet, create one
                $this->object_relation_path_from_parent = RelationPathFactory::createForObject($this->getParent()->getMetaObject());
                // If the parent is based on another object, search for a relation to it - append it to the path if found
                if (! $this->getParent()->getMetaObject()->is($this->getMetaObject())) {
                    if ($this->object_relation_path_to_parent) {
                        // If we already know the path from this widgets object to the parent, just reverse it
                        $this->object_relation_path_from_parent = $this->getObjectRelationPathToParent()->reverse();
                    } elseif ($rel = $this->getParent()->getMetaObject()->findRelation($this->getMetaObject(), true)) {
                        // Otherwise, try to find a path automatically
                        $this->object_relation_path_from_parent->appendRelation($rel);
                    }
                }
            }
        } elseif (! ($this->object_relation_path_from_parent instanceof RelationPath)) {
            $this->object_relation_path_from_parent = RelationPathFactory::createFromString($this->getParent()->getMetaObject(), $this->object_relation_path_from_parent);
        } else {
            // If there is a relation path already built, check if it still fits to the current parent widget (which might have changed)
            // If not, removed the cached path and runt the getter again to try to find a new path
            if (! $this->getParent()->getMetaObject()->is($this->object_relation_path_from_parent->getStartObject())) {
                $this->object_relation_path_from_parent = null;
                return $this->getObjectRelationPathFromParent();
            }
        }
        return $this->object_relation_path_from_parent;
    }

    /**
     * Sets the relation path from the parent widget's object to this widget's object
     *
     * @uxon-property object_relation_path_from_parent
     * @uxon-type metamodel:relation
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setObjectRelationPathFromParent()
     */
    public function setObjectRelationPathFromParent($string)
    {
        $this->object_relation_path_from_parent = $string;
        if ($this->isObjectInheritedFromParent()) {
            $this->setObjectAlias($this->getParent()->getMetaObject()->getRelatedObject($string)->getAliasWithNamespace());
        }
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isObjectInheritedFromParent()
     */
    public function isObjectInheritedFromParent()
    {
        return null !== $this->object_qualified_alias;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getObjectRelationPathToParent()
     */
    public function getObjectRelationPathToParent()
    {
        if (is_null($this->object_relation_path_to_parent)) {
            // If there is no relation to the parent set yet, see if there is a parent.
            // If not, do not do anything - maybe there will be some parent when the method is called the next time
            if ($this->getParent()) {
                // If there is no relation path yet, create one
                $this->object_relation_path_to_parent = RelationPathFactory::createForObject($this->getMetaObject());
                // If the parent is based on another object, search for a relation to it - append it to the path if found
                if (! $this->getParent()->getMetaObject()->is($this->getMetaObject())) {
                    if ($this->object_relation_path_from_parent) {
                        // If we already know the path from the parents object to this widget, just reverse it
                        $this->object_relation_path_to_parent = $this->getObjectRelationPathToParent()->reverse();
                    } elseif ($rel = $this->getMetaObject()->findRelation($this->getParent()->getMetaObject(), true)) {
                        $this->object_relation_path_to_parent->appendRelation($rel);
                    }
                }
            }
        } elseif (! ($this->object_relation_path_to_parent instanceof RelationPath)) {
            // If there is a path, but it is a string (e.g. it was just set via UXON import), create an object from it
            $this->object_relation_path_to_parent = RelationPathFactory::createFromString($this->getMetaObject(), $this->object_relation_path_to_parent);
        } else {
            // If there is a relation path already built, check if it still fits to the current parent widget (which might have changed)
            // If not, removed the cached path and runt the getter again to try to find a new path
            if (! $this->getParent()->getMetaObject()->is($this->object_relation_path_to_parent->getEndObject())) {
                $this->object_relation_path_to_parent = null;
                return $this->getObjectRelationPathToParent();
            }
        }
        return $this->object_relation_path_to_parent;
    }

    /**
     * Sets the relation path from this widget's meta object to the object of the parent widget
     *
     * @uxon-property object_relation_path_to_parent
     * @uxon-type metamodel:relation
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setObjectRelationPathToParent()
     */
    public function setObjectRelationPathToParent($string)
    {
        $this->object_relation_path_to_parent = $string;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getParent()
     */
    public function getParent()
    {
        return $this->parent;
    }
    
    public function hasParent()
    {
        return is_null($this->parent) ? false : true;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setParent()
     */
    public function setParent(WidgetInterface $widget)
    {
        $this->parent = $widget;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getHint()
     */
    public function getHint()
    {
        if (! $this->hint && ($this instanceof iShowSingleAttribute) && $this->isBoundToAttribute() && $this->getAttribute()) {
            $this->setHint($this->getAttribute()->getHint() . ' [' . $this->getAttribute()->getAlias() . ']');
        }
        return $this->hint;
    }

    /**
     * Sets a hint message for the widget.
     * The hint will typically be used for pop-overs, etc.
     *
     * @uxon-property hint
     * @uxon-type string|metamodel:formula
     * @uxon-translatable true
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setHint()
     */
    public function setHint($value)
    {
        $this->hint = $this->evaluatePropertyExpression($value);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isHidden()
     */
    public function isHidden()
    {
        return $this->getVisibility() == EXF_WIDGET_VISIBILITY_HIDDEN ? true : false;
    }

    /**
     * Set to TRUE to hide the widget.
     * The same effect can be achieved by setting "visibility: hidden".
     *
     * Setting "hidden: false" will revert visibility to normal - just like "visibility: normal".
     *
     * @uxon-property hidden
     * @uxon-type boolean
     * @uxon-default false
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setHidden()
     */
    public function setHidden($value)
    {
        $value = BooleanDataType::cast($value);
        if ($value) {
            $this->setVisibility(EXF_WIDGET_VISIBILITY_HIDDEN);
        } else {
            $this->setVisibility(EXF_WIDGET_VISIBILITY_NORMAL);
        }
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getPrefillData()
     */
    public function getPrefillData()
    {
        return $this->prefill_data;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setPrefillData()
     */
    public function setPrefillData(DataSheetInterface $data_sheet)
    {
        $this->prefill_data = $data_sheet;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::implementsInterface()
     */
    public function implementsInterface($interface_name)
    {
        $type_class = '\\exface\\Core\\Interfaces\\Widgets\\' . $interface_name;
        if ($this instanceof $type_class) {
            return true;
        } else {
            return false;
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::is()
     */
    public function is($type)
    {
        $type_class = '\\exface\\Core\\Widgets\\' . $type;
        if ($this instanceof $type_class) {
            return true;
        } else {
            return false;
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isExactly()
     */
    public function isExactly($widget_type)
    {
        $type_class = 'exface\\Core\\Widgets\\' . $widget_type;
        if (get_class($this) === $type_class) {
            return true;
        }
        return false;
    }

    /**
     * Forces the widget to use the specified data connection.
     * 
     * Use with care: if widgets on a single page use different connections for the same
     * object, the resulting data will be unpredictable and probably broken!
     * 
     * @uxon-property data_connection_alias
     * @uxon-type metamodel:connection
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setDataConnectionAlias()
     */
    public function setDataConnectionAlias($value)
    {
        $this->data_connection_alias_specified_by_user = $value;
        $this->getMetaObject()->setDataConnectionAlias($value);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WorkbenchDependantInterface::getWorkbench()
     */
    public function getWorkbench()
    {
        return $this->getPage()->getWorkbench();
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getPage()
     */
    public function getPage()
    {
        return $this->page;
    }

    /**
     * Returns the translation string for the given message id.
     *
     * This is a shortcut for calling $this->getApp()->getTranslator()->translate().
     *
     * @see Translation::translate()
     *
     * @param string $message_id            
     * @param array $placeholders            
     * @param float $number_for_plurification            
     * @return string
     */
    public function translate($message_id, array $placeholders = null, $number_for_plurification = null)
    {
        $message_id = trim($message_id);
        return $this->getWorkbench()->getCoreApp()->getTranslator()->translate($message_id, $placeholders, $number_for_plurification);
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getDoNotPrefill()
     */
    public function getDoNotPrefill()
    {
        return $this->do_not_prefill;
    }

    /**
     * Set to TRUE to not prefill the widget with any action data.
     * 
     * @uxon-property do_not_prefill
     * @uxon-type boolean
     * @uxon-default false
     * 
     * @see \exface\Core\Interfaces\WidgetInterface::setDoNotPrefill()
     */
    public function setDoNotPrefill($value)
    {
        $this->do_not_prefill = BooleanDataType::cast($value);
        return $this;
    }

    /**
     * @deprecated use setDisabledIf() instead!
     * 
     * E.g.:
     * 
     * ```json
     *  "disable_condition": {
     *      "widget_link": "consumer!CONSUMER_MAIL_PHONE",
     *      "comparator": "!=",
     *      "value": ""
     *  }
     *  
     * ```
     * 
     * means the current widget is disabled when the column CONSUMER_MAIL_PHONE of
     * widget consumer is not empty. Can be usefully combined with a value-reference
     * to the same widget and column.
     *
     * @param UxonObject $value            
     * @return \exface\Core\Widgets\AbstractWidget
     */
    public function setDisableCondition($value)
    {
        return $this->setDisabledIf($value);
    }
    
    /**
     * Sets a condition to disable the widget.
     *
     * Examples
     * 
     * Disable an `Input` if checkbox not checked:
     *
     * ```json
     *  "widget_type": "Input"
     *  "disabled_if": {
     *      "value_left": "id_of_checkbox",
     *      "comparator": "!=",
     *      "value_right": "1"
     *  }
     *
     * ```
     * 
     * Disable a `Button` if selected table row does not have required data:
     *
     * ```json
     *  "widget_type": "Button",
     *  "caption": "Call",
     *  "disabled_if": {
     *      "value_left": "id_of_table!PHONE_NUMBER",
     *      "comparator": "==",
     *      "value_right": ""
     *  }
     *
     * ```
     * 
     * Disable a `Button` on a complex AND-condition
     * 
     * ```json
     *  "widget_type": "Button",
     *  "caption": "Call",
     *  "disabled_if": {
     *      "operator": "AND",
     *      "conditions": [
     *          {
     *              "value_left": "id_of_table!PHONE_NUMBER",
     *              "comparator": "==",
     *              "value_right": ""
     *          },{
     *              "value_left": "id_of_table!ALLOW_PHONE_CALLS",
     *              "comparator": "==",
     *              "value_right": "1"
     *          }
     *      ]
     *  }
     *
     * ```
     *
     * @uxon-property disabled_if
     * @uxon-type \exface\Core\Widgets\Parts\ConditionalProperty
     * @uxon-template {"operator": "AND", "conditions": [{"value_left": "", "comparator": "", "value_right": ""}]}
     *
     * @param UxonObject $value
     * @return \exface\Core\Widgets\AbstractWidget
     */
    public function setDisabledIf(UxonObject $uxon) : WidgetInterface
    {
        $this->disabled_if = $uxon;
        return $this;
    }

    /**
     * 
     * @return ConditionalProperty|NULL
     */
    public function getDisabledIf() : ?ConditionalProperty
    {
        if ($this->disabled_if === null) {
            return null;
        }
        
        if (! ($this->disabled_if instanceof ConditionalProperty)) {
            $this->disabled_if = new ConditionalProperty($this, 'disabled_if', $this->disabled_if);
        }
        
        return $this->disabled_if;
    }
    
    /**
     * Returns the closest parent widget which implements the passed class or interface.
     * 
     * Returns null if no such parent widget exists.
     *
     * @param string $classOrInterface            
     * @return WidgetInterface|NULL
     */
    public function getParentByClass(string $classOrInterface) : ?WidgetInterface
    {
        if (! array_key_exists($classOrInterface, $this->parentByType)) {
            $widget = $this;
            while ($widget->getParent()) {
                $widget = $widget->getParent();
                
                // Ein Filter is eher ein Wrapper als ein Container (kann nur ein Widget enthalten).
                if (($classOrInterface == 'exface\\Core\\Interfaces\\Widgets\\iContainOtherWidgets') && ($widget instanceof $classOrInterface) && ($widget instanceof Filter)) {
                    continue;
                }
                
                if ($widget instanceof $classOrInterface) {
                    $this->parentByType[$classOrInterface] = $widget;
                    break;
                }
            }
            
            if (! array_key_exists($classOrInterface, $this->parentByType)) {
                $this->parentByType[$classOrInterface] = null;
            }
        }
        return $this->parentByType[$classOrInterface];
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\iCanBeCopied::copy()
     */
    public function copy()
    {
        return WidgetFactory::createFromUxon($this->getPage(), $this->exportUxonObject(), $this->getParent());
    }
    
    /**
     * This is a shortcut to calling $this->getWorkbench()->eventManager()->dispatch()
     * 
     * @param EventInterface $event
     * @return AbstractWidget
     */
    protected function dispatchEvent(EventInterface $event) : AbstractWidget
    {
        $this->getWorkbench()->eventManager()->dispatch($event);
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getFacadeOptions()
     */
    public function getFacadeOptions(FacadeInterface $facade) : ?UxonObject
    {
        if ($this->facadeOptions === null) {
            return null;
        }
        foreach ($this->facadeOptions as $facadeSelectorString => $uxon) {
            $facadeSelector = SelectorFactory::createFacadeSelector($this->getWorkbench(), $facadeSelectorString);
            if ($facade->is($facadeSelector)) {
                return $uxon;
            }
        }
        return null;
    }
    
    /**
     * Facade-specific options for this widget defined for each facade
     * 
     * Example:
     * 
     * ```
     * {
     *  "facade_options": {
     *      "exface.AdminLTEFacade.AdminLTEFacade": {
     *          "option_1": "value_of_option_1",
     *          "option_2": "value_of_option_2"
     *      }
     *  }
     * }
     * 
     * ```
     * 
     * @uxon-property facade_options
     * @uxon-type object
     * @uxon-template {"": {"": ""}}
     * 
     * @param UxonObject $value
     * @return AbstractWidget
     */
    public function setFacadeOptions(UxonObject $value) : WidgetInterface
    {
        $this->facadeOptions = $value;
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::hasFacadeOptions()
     */
    public function hasFacadeOptions(FacadeInterface $facade) : bool
    {
        return $this->getFacadeOptions($facade) !== null;
    }
}