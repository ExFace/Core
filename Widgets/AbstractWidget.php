<?php
namespace exface\Core\Widgets;

use exface\Core\Interfaces\DataSheets\DataSheetInterface;
use exface\Core\Interfaces\Widgets\iShowSingleAttribute;
use exface\Core\Interfaces\WidgetInterface;
use exface\Core\Interfaces\Model\MetaObjectInterface;
use exface\Core\Factories\WidgetDimensionFactory;
use exface\Core\Interfaces\Model\UiPageInterface;
use exface\Core\Factories\RelationPathFactory;
use exface\Core\Exceptions\Widgets\WidgetIdConflictError;
use exface\Core\Exceptions\Widgets\WidgetPropertyInvalidValueError;
use exface\Core\Exceptions\Widgets\WidgetConfigurationError;
use exface\Core\Exceptions\Widgets\WidgetPropertyUnknownError;
use exface\Core\CommonLogic\UxonObject;
use exface\Core\DataTypes\BooleanDataType;
use exface\Core\CommonLogic\Traits\ImportUxonObjectTrait;
use exface\Core\Exceptions\UxonMapError;
use exface\Core\Exceptions\Widgets\WidgetHasNoMetaObjectError;
use exface\Core\Factories\WidgetFactory;
use exface\Core\CommonLogic\Translation;
use exface\Core\Interfaces\Selectors\AliasSelectorInterface;
use exface\Core\Events\Widget\OnBeforePrefillEvent;
use exface\Core\Events\Widget\OnPrefillEvent;
use exface\Core\Interfaces\Events\EventInterface;
use exface\Core\Factories\DataSheetFactory;
use exface\Core\Widgets\Traits\iHaveCaptionTrait;
use exface\Core\Uxon\WidgetSchema;
use exface\Core\Widgets\Traits\iHaveVisibilityTrait;
use exface\Core\DataTypes\StringDataType;
use exface\Core\Widgets\Parts\ConditionalProperty;
use exface\Core\Interfaces\Facades\FacadeInterface;
use exface\Core\Factories\SelectorFactory;
use exface\Core\Interfaces\Model\MetaRelationPathInterface;
use exface\Core\Interfaces\Widgets\iTakeInput;
use exface\Core\Contexts\DebugContext;
use exface\Core\DataTypes\WidgetVisibilityDataType;
use exface\Core\CommonLogic\Translation\TranslationsArray;

/**
 * Base class for facade elements in AJAX facades using jQuery
 *
 * @author Andrej Kabachnik
 *        
 */
abstract class AbstractWidget implements WidgetInterface
{
    use ImportUxonObjectTrait {
		importUxonObject as importUxonObjectDefault;
	}
	use iHaveCaptionTrait;
	use iHaveVisibilityTrait;
	
	/**
	 * Reset the widget to the initial state - i.e. removing any user changes
	 * 
	 * If the widget was prefilled, it will be resetted to the prefill data.
	 *
	 * @uxon-property reset
	 *
	 * @var string
	 */
	const FUNCTION_RESET = 'reset';
	
	/**
	 * Refresh the widget - in particular reload data from the server or widget links
	 *
	 * @uxon-property refresh
	 *
	 * @var string
	 */
	const FUNCTION_REFRESH = 'refresh';
	
	/**
	 * Enable the widget if disabled
	 *
	 * @uxon-property enable
	 *
	 * @var string
	 */
	const FUNCTION_ENABLE = 'enable';
	
	/**
	 * Disable the widget if enabled
	 *
	 * @uxon-property disable
	 *
	 * @var string
	 */
	const FUNCTION_DISABLE = 'disable';

    private $id_specified = null;

    private $id_autogenerated = null;

    private $hint = null;
    
    private $hint_generated = null;

    private $widget_type = null;
    
    private $meta_object = null;

    private $object_alias = null;

    private $relation_path_to_parent_string = null;
    
    private $relation_path_to_parent = null;

    private $object_qualified_alias = null;

    private $disabled = null;
    
    private $disabled_if = null;
    
    private $disabled_reason = null;

    private $width = null;

    private $height = null;

    private $visibility = null;
    
    private $hidden_if = null;

    /** @var \exface\Core\Widgets\AbstractWidget the parent widget */
    private $parent = null;

    private $ui = null;

    private $data_connection_alias_specified_by_user = NULL;

    private $prefill_data = null;

    private $uxon_original = null;

    private $page = null;

    private $do_not_prefill = false;

    private $id_space = null;

    private $parentByType = [];
    
    private $facadeOptions = null;
    
    private $customTranslations = null;
    
    /**
     * @var string|UxonObject
     */
    private $extendedFrom = null;

    /**
     *
     * @deprecated use WidgetFactory::create() instead!
     * @param UiPageInterface $page            
     * @param WidgetInterface $parent_widget            
     * @param string $fixed_widget_id            
     */
    function __construct(UiPageInterface $page, WidgetInterface $parent_widget = null, $fixed_widget_id = null)
    {
        $this->page = $page;
        $this->widget_type = static::getWidgetTypeFromClass(get_class($this));
        // Set the parent widget if known
        if ($parent_widget) {
            $this->setParent($parent_widget);
        }
        
        if ($fixed_widget_id) {
            $this->setIdSpecified($fixed_widget_id);
        }
        
        // Add widget to the page. It will now get an autogenerated id
        $page->addWidget($this);
        $this->init();
    }

    public static function getWidgetTypeFromClass($class_name)
    {
        return substr($class_name, (strrpos($class_name, '\\') + 1));
    }

    /**
     * This method is called every time a widget is instantiated an can be used as a hook for additional initializing logics.
     *
     * @return void
     */
    protected function init()
    {}

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::importUxonObject()
     */
    public function importUxonObject(UxonObject $uxon)
    {
        // Save the original UXON description
        $this->uxon_original = $uxon->copy();
        
        // Now do the actual importing
        // First look for an object alias. It must be assigned before the rest because many other properties depend on having the right object
        if ($uxon->hasProperty('object_alias')) {
            $this->setObjectAlias($uxon->getProperty('object_alias'));
        }
        // Same goes for id and id_space
        if ($uxon->hasProperty('id_space')) {
            $this->setIdSpace($uxon->getProperty('id_space'));
            $uxon->unsetProperty('id_space');
        }
        if ($uxon->hasProperty('id')) {
            $this->setId($uxon->getProperty('id'));
            $uxon->unsetProperty('id');
        }
        
        try {
            return $this->importUxonObjectDefault($uxon);
        } catch (UxonMapError $e) {
            throw new WidgetPropertyUnknownError($this, 'Unknown UXON property found for widget "' . $this->getWidgetType() . '": ' . $e->getMessage(), '6UNTXJE', $e);
        }
        return;
    }
    
    /**
     *
     * {@inheritdoc}
     * @see \exface\Core\Interfaces\iCanBeConvertedToUxon::getUxonSchemaClass()
     */
    public static function getUxonSchemaClass() : ?string
    {
        return WidgetSchema::class;
    }

    public function exportUxonObject()
    {
        $uxon = $this->exportUxonObjectOriginal();
        
        if ($this->getIdSpecified()) {
            $uxon->setProperty('id', $this->getId());
        }
        $uxon->setProperty('widget_type', $this->getWidgetType());
        $uxon->setProperty('object_alias', $this->getMetaObject()->getAliasWithNamespace());
        
        $this->exportUxonObjectAddCaptionPoperties($uxon);
        
        if ($this->disabled !== null) {
            $uxon->setProperty('disabled', $this->isDisabled());
        }
        if ($this->disabled_if !== null) {
            $uxon->setProperty('disabled_if', $this->getDisabledIf()->exportUxonObject());
        }
        
        if ($this->hint !== null) {
            $uxon->setProperty('hint', $this->getHint());
        }
        if ($this->getVisibility() !== null) {
            $uxon->setProperty('visibility', $this->getVisibility());
        }
        if (! $this->getWidth()->isUndefined()) {
            $uxon->setProperty('width', $this->getWidth()->toString());
        }
        if (! $this->getHeight()->isUndefined()) {
            $uxon->setProperty('height', $this->getHeight()->toString());
        }
        return $uxon;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::exportUxonObjectOriginal()
     */
    public function exportUxonObjectOriginal()
    {
        if ($this->uxon_original instanceof UxonObject) {
            return $this->uxon_original;
        } else {
            return new UxonObject();
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::prefill()
     */
    public final function prefill(DataSheetInterface $data_sheet)
    {
        if ($this->getDoNotPrefill()) {
            return;
        }
        $this->getWorkbench()->eventManager()->dispatch(new OnBeforePrefillEvent($this, $data_sheet));
        $this->setPrefillData($data_sheet);
        $this->doPrefill($data_sheet);
        $this->getWorkbench()->eventManager()->dispatch(new OnPrefillEvent($this, $data_sheet));
        return;
    }
    
    /**
     * Prefills the widget using values from the given data sheet.
     * 
     * Override this method for custom prefill logic of a widget. By default it
     * will not do anything at all. 
     * 
     * IMPORTANT: don't forget to dispatch a `OnPrefillChangePropertyEvent` every
     * time you change a widget from your prefill logic!
     * 
     * @param DataSheetInterface $data_sheet
     * 
     * @triggers exface\Core\Events\Widget\OnPrefillChangePropertyEvent
     * 
     * @return void
     */
    protected function doPrefill(DataSheetInterface $data_sheet)
    {
        return;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::prepareDataSheetToRead()
     */
    public function prepareDataSheetToRead(DataSheetInterface $data_sheet = null)
    {
        if (is_null($data_sheet)) {
            $data_sheet = DataSheetFactory::createFromObject($this->getMetaObject());
        }
        return $data_sheet;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::prepareDataSheetToPrefill()
     */
    public function prepareDataSheetToPrefill(DataSheetInterface $data_sheet = null) : DataSheetInterface
    {
        if (is_null($data_sheet)) {
            $data_sheet = DataSheetFactory::createFromObject($this->getMetaObject());
        }
        return $data_sheet;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::isPrefillable()
     */
    public function isPrefillable()
    {
        return ! $this->getDoNotPrefill();
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::isPrefilled()
     */
    public function isPrefilled() : bool
    {
        return $this->prefill_data !== null;
    }

    /**
     * Sets the widget type (= widget selector).
     * 
     * In contrast to the widget selector, the widget type has only two syntax variants:
     * - the name of the widget (e.g. `DataTable`) for core widgets
     * - a namespaced widget alias for custom widgets from other apps (i.e. `my.App.MyCustomWidget`).
     *
     * @uxon-property widget_type
     * @uxon-type metamodel:widget
     *
     * @param string $selectorString    
     * @return WidgetInterface        
     */
    protected function setWidgetType($selectorString) : WidgetInterface
    {
        if ($selectorString) {
            if (stripos($selectorString, 'exface.Core.') === 0) {
                $this->widget_type = str_replace('exface.Core.', '', $selectorString);
            } elseif (strpos($selectorString, '/') !== false || strpos($selectorString, '\\') !== false) {
                throw new WidgetPropertyInvalidValueError('Invalid widget type "' . $selectorString . '": classname and filepath selectors not yet supported - please use alias!');
            } else {
                $this->widget_type = $selectorString;
            }
        }
        return $this;
    }
    
    /**
     * Explicitly specifies the ID of the widget.
     * The ID must be unique on every page containing the widget and can be used in widget links
     *
     * @uxon-property id
     * @uxon-type string
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setId()
     */
    function setId($id)
    {
        return $this->setIdSpecified($id);
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::hasChildren()
     */
    public function hasChildren() : bool
    {
        foreach ($this->getChildren() as $child) {
            return true;
        }
        return false;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getChildren()
     */
    public function getChildren() : \Iterator
    {
        return new \EmptyIterator();
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getChildrenRecursive()
     */
    public function getChildrenRecursive() : \Iterator
    {
        // Use a generator here because widgets with lot's of children (e.g. large editor dialogs)
        // will need to instantiate ALL their children first if we use an array. This is useless,
        // since in many cases getChildrenRecursive is used to look for some widgets in shallow
        // recursion levels.
        // For the same reason first yield the direct children an than yield children's children
        // - this makes the method return children by levels and not by recursion path.
        foreach ($this->getChildren() as $child) {
            yield $child;
        }
        
        foreach ($this->getChildren() as $child) {
            yield from $child->getChildrenRecursive();
            // Excplicitly continue - otherwise the foreach will break after the first yield from
            continue;
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getMetaObject()
     */
    function getMetaObject()
    {
        if ($this->meta_object === null) {
            switch (true) {
                case $this->object_qualified_alias:
                    $obj = $this->getWorkbench()->model()->getObject($this->object_qualified_alias);
                    break;
                case $this->hasParent():
                    $obj = $this->getParent()->getMetaObject();
                    if ($this->relation_path_to_parent_string !== null) {
                        $relPath = RelationPathFactory::createFromString($obj, $this->relation_path_to_parent_string);
                        $obj = $relPath->getEndObject();
                    }
                    break;
                default:
                    throw new WidgetHasNoMetaObjectError($this, 'A widget must have either an object_id, an object_alias or a parent widget with an object reference!');
            }
            $this->setMetaObject($obj);
        }
        return $this->meta_object;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setMetaObject()
     */
    function setMetaObject(MetaObjectInterface $object)
    {
        $this->meta_object = $object;
        $this->relation_path_to_parent = null;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getId()
     */
    public function getId(bool $includeNamespace = true) : ?string
    {
        return $this->getIdSpecified($includeNamespace) ?? $this->getIdAutogenerated();
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getIdSpecified()
     */
    public function getIdSpecified(bool $includeIdSpace = true) : ?string
    {
        if ($includeIdSpace === false) {
            $withNs = $this->id_specified ?? '';
            return StringDataType::substringAfter($withNs, $this->getIdSpace() . $this->getPage()->getWidgetIdSpaceSeparator(), $withNs);
        }
        return $this->id_specified;
    }

    /**
     * 
     * @param string $value
     * @throws WidgetIdConflictError
     * @return AbstractWidget
     */
    protected function setIdSpecified(string $value) : AbstractWidget
    {
        $value = ($this->getIdSpace() ? $this->getIdSpace() . $this->getPage()->getWidgetIdSpaceSeparator() : '') . $value;
        
        // Don't do anything, if the id's are identical
        if ($this->getId() === $value) {
            return $this;
        }
        
        // Remember current id to remove it from the page afterwards
        $old_id_specified = $this->id_specified;
        // Set the new id
        $this->id_specified = $value;
        
        // Try to add the widget with the new id to the page (again). If it fails, restore the old id
        // NOTE: the widget will be now added to the page twice - with the old and the new id. This
        // is neccessary as other code may have already used the old id and will rely on it. On the
        // other hand the old id was unique and the new one is too, so there should not be any problems!
        try {
            $this->getPage()->addWidget($this);
        } catch (WidgetIdConflictError $e) {
            $this->id_specified = $old_id_specified;
            throw $e;
        }
        
        return $this;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getIdAutogenerated()
     */
    public function getIdAutogenerated() : ?string
    {
        return $this->id_autogenerated;
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::setIdAutogenerated()
     */
    public function setIdAutogenerated($value)
    {
        $this->id_autogenerated = $value;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getIdSpace()
     */
    public function getIdSpace()
    {
        if ($this->id_space === null) {
            if ($this->hasParent() && $parent_id_space = $this->getParent()->getIdSpace()) {
                $this->id_space = $parent_id_space;
            } else {
                return '';
            }
        }
        return $this->id_space;
    }

    /**
     * Separates the children of the widget into a separate id space within the page.
     *
     * Multiple widgets with the same id can coexist in a page if the are placed in separate id spaces.
     * This is usefull to reuse complex widgets with live references multiple times on one page. For
     * example, if you have created a complex editor dialog and want to extend from it to create separate
     * buttons for creating a new object and editing one, you can specify a custom id space for each
     * of the buttons - this way, the live references within the button's action will work although
     * the ids specified in them are not unique on the page anymore.
     *
     * @uxon-property id_space
     * @uxon-type string
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setIdSpace()
     */
    public function setIdSpace($value)
    {
        $id_space_old = $this->id_space;
        $this->id_space = $value;
        // If the id space changes and the widget has an explicit id, make sure the id is reregistered.
        // This will transfer the id into the new id space.
        if ($value != $id_space_old && $this->getIdSpecified()) {
            $this->setId($this->getIdSpecified());
        }
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getWidgetType()
     */
    function getWidgetType()
    {
        return $this->widget_type;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isDisabled()
     */
    public function isDisabled() : ?bool
    {
        return $this->disabled;
    }

    /**
     * Set to TRUE to disable the widget.
     * 
     * Disabled widgets cannot accept input or interact with the user in any other way.
     *
     * @uxon-property disabled
     * @uxon-type boolean
     * @uxon-default false
     * 
     * @see \exface\Core\Interfaces\WidgetInterface::setDisabled()
     */
    public function setDisabled(?bool $trueOrFalseOrNull, string $reason = null) : WidgetInterface
    {
        $this->disabled = $trueOrFalseOrNull;
        $this->disabled_reason = $reason;
        return $this;
    }
    
    /**
     * 
     * @return string|NULL
     */
    protected function getDisabledReason() : ?string
    {
        return $this->disabled_reason;
    }

    /**
     *
     * {@inheritdoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getWidth()
     */
    public function getWidth()
    {
        if (! $this->width) {
            $exface = $this->getWorkbench();
            $this->width = WidgetDimensionFactory::createEmpty($exface);
        }
        return $this->width;
    }

    /**
     * Sets the width of the widget.
     * Set to `1` for default widget width in a facade or `max` for maximum width possible.
     *
     * The width can be specified either in
     * - facade-specific relative units (e.g. `width: 2` makes the widget twice as wide
     * as the default width of a widget in the current facade)
     * - percent (e.g. `width: 50%` will make the widget take up half the available space)
     * - any other facade-compatible units (e.g. `width: 200px` will work in CSS-based facades)
     *
     * @uxon-property width
     * @uxon-type string
     *
     * {@inheritdoc}
     * @see \exface\Core\Interfaces\WidgetInterface::setWidth()
     */
    public function setWidth($value)
    {
        $exface = $this->getWorkbench();
        $this->width = WidgetDimensionFactory::createFromAnything($exface, $value);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getHeight()
     */
    public function getHeight()
    {
        if (! $this->height) {
            $exface = $this->getWorkbench();
            $this->height = WidgetDimensionFactory::createEmpty($exface);
        }
        return $this->height;
    }

    /**
     * Sets the height of the widget.
     * Set to `1` for default widget height in a facade or `max` for maximum height possible.
     *
     * The height can be specified either in
     * - facade-specific relative units (e.g. `height: 2` makes the widget twice as high
     * as the default width of a widget in the current facade)
     * - percent (e.g. `height: 50%` will make the widget take up half the available space)
     * - any other facade-compatible units (e.g. `height: 200px` will work in CSS-based facades)
     *
     * @uxon-property height
     * @uxon-type string
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setHeight()
     */
    public function setHeight($value)
    {
        $exface = $this->getWorkbench();
        $this->height = WidgetDimensionFactory::createFromAnything($exface, $value);
        return $this;
    }

    /**
     * Sets the alias of the main object of the widget.
     * Use qualified aliases (with namespace)!
     *
     * @uxon-property object_alias
     * @uxon-type metamodel:object
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setObjectAlias()
     */
    public function setObjectAlias($full_or_object_alias)
    {
        // If it's a fully qualified alias, use it directly
        if ($ns = $this->getWorkbench()->model()->getNamespaceFromQualifiedAlias($full_or_object_alias)) {
            $this->object_qualified_alias = $full_or_object_alias;
            $this->object_alias = $this->getWorkbench()->model()->getObjectAliasFromQualifiedAlias($full_or_object_alias);
        } else {
            // ... if the namespace is missing, get it from the app of the parent object
            if ($this->getParent()) {
                $ns = $this->getParent()->getMetaObject()->getNamespace();
            }
            
            if (! $ns) {
                throw new WidgetConfigurationError($this, 'Cannot set object_alias property for widget "' . $this->getId() . '": neither a namespace is specified, nor is there a parent widget to take it from!', '6UOD4TW');
            }
            $this->object_alias = $full_or_object_alias;
            $this->object_qualified_alias = $ns . AliasSelectorInterface::ALIAS_NAMESPACE_DELIMITER . $this->object_alias;
        }
        
        // IMPORTANT: unset the meta_object of this class, because it may already have been 
        // initialized previously. Do the same for the relation path to the parent widget
        $this->meta_object = null;
        $this->relation_path_to_parent = null;
        
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getObjectRelationPathFromParent()
     */
    public function getObjectRelationPathFromParent() : ? MetaRelationPathInterface
    {
        return $this->getObjectRelationPathToParent()->reverse();
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isObjectInheritedFromParent()
     */
    public function isObjectInheritedFromParent() : bool
    {
        return $this->object_qualified_alias === null && $this->relation_path_to_parent_string === null;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getObjectRelationPathToParent()
     */
    public function getObjectRelationPathToParent() : ?MetaRelationPathInterface
    {
        if ($this->relation_path_to_parent === null) {
            switch (true) {
                // If there is was a path provided as a string, instantiate it as a path object
                case $this->relation_path_to_parent_string !== null:
                    $this->relation_path_to_parent = RelationPathFactory::createFromString($this->getMetaObject(), $this->relation_path_to_parent_string);
                    break;
                // If there is no parent or the parent widget has the same object as this one,
                // return an empty relation path
                case ! $this->hasParent():
                case $this->isObjectInheritedFromParent():
                case $this->getMetaObject()->isExactly($this->getParent()->getMetaObject()):
                    $this->relation_path_to_parent = RelationPathFactory::createForObject($this->getMetaObject());
                    break;
                // If no path is known and the objects are not the same (checked above), attempt
                // to find a path. Return NULL if this fails.
                case $this->relation_path_to_parent_string === null:
                    if ($path = $this->getMetaObject()->findRelationPath($this->getParent()->getMetaObject())) {
                        $this->relation_path_to_parent = $path;
                    } else {
                        return null;
                    }
            }
        }
        return $this->relation_path_to_parent;
    }

    /**
     * Sets the relation path from this widget's meta object to the object of the parent widget
     *
     * @uxon-property object_relation_path_to_parent
     * @uxon-type metamodel:relation
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setObjectRelationPathToParent()
     */
    public function setObjectRelationPathToParent($string)
    {
        $this->relation_path_to_parent_string = $string;
        $this->meta_object = null;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getParent()
     */
    public function getParent()
    {
        return $this->parent;
    }
    
    public function hasParent()
    {
        return is_null($this->parent) ? false : true;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setParent()
     */
    public function setParent(WidgetInterface $widget)
    {
        $this->parent = $widget;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getHint()
     */
    public function getHint()
    {
        if ($this->hint !== null) {
            $hint = $this->hint;
        } else {
            if (! $this->hint_generated && ($this instanceof iShowSingleAttribute) && $this->isBoundToAttribute()) {
                $attr = $this->getAttribute();
                switch (true) {
                    case $this->hasAggregator():
                        $hint = '';
                        break;
                    case $attr->getRelationPath()->isEmpty() === false && $this->isBoundToLabelAttribute():
                        $hint = $attr->getRelationPath()->getRelationLast()->getLeftKeyAttribute()->getHint();
                        break;
                    default:
                        $hint = $attr->getHint();
                        break;
                }
                $this->hint_generated = $this->evaluatePropertyExpression($hint);                
            }
            $hint = $this->hint_generated;
        }
        
        // Input specific formatting 
        if ($this instanceof iTakeInput && ($this instanceof iShowSingleAttribute) && $this->isBoundToAttribute() && $this->isDisabled() !== true) {
            $attr = $this->getAttribute();
            if ($dataTypeHint = $attr->getDataType()->getInputFormatHint()) {
                $hint .= ($hint ? "\n\n" : '') . $this->translate('LOCALIZATION.DATATYPE.FORMAT_HINT') . $dataTypeHint;
            }
            
            if ($this->isRequired() === true) {
                $hint .= ($hint ? "\n\n" : '') . $this->translate('WIDGET.INPUT.REQUIRED_HINT');
            }
        }
        
        // Disabled reason
        if ($hint && $this->isDisabled() && $disabledReason = $this->getDisabledReason()) {
            $hint .= $disabledReason;
        }
        
        // Dev-hint
        if (($this instanceof iShowSingleAttribute) && $this->getWorkbench()->getContext()->getScopeWindow()->hasContext(DebugContext::class) && $this->isBoundToAttribute() && $attr = $this->getAttribute()) {
            $hint = rtrim(rtrim($hint), '.') .  ".\n\nDebug-hint: attribute alias '{$this->getAttributeAlias()}'"; 
        }
        return $hint;
    }

    /**
     * Sets a hint message for the widget.
     * The hint will typically be used for pop-overs, etc.
     *
     * @uxon-property hint
     * @uxon-type string|metamodel:formula
     * @uxon-translatable true
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setHint()
     */
    public function setHint($value)
    {
        $this->hint = $this->evaluatePropertyExpression($value);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isHidden()
     */
    public function isHidden()
    {
        return $this->getVisibility() === WidgetVisibilityDataType::HIDDEN;
    }

    /**
     * Set to TRUE to hide the widget - the same effect can be achieved by setting `visibility: hidden`.
     *
     * Setting `hidden: false` will revert visibility to its original value or `normal` if no original 
     * value can be determined.
     *
     * @uxon-property hidden
     * @uxon-type boolean
     * @uxon-default false
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setHidden()
     */
    public function setHidden($value)
    {
        $value = BooleanDataType::cast($value);
        if ($value === true) {
            $this->setVisibility(WidgetVisibilityDataType::HIDDEN);
        } elseif ($this->isHidden() === true) {
            if ($this->uxon_original && $this->uxon_original->hasProperty('visibility')) {
                $this->setVisibility($this->uxon_original->getProperty('visibility'));
            } else {
                $this->setVisibility(WidgetVisibilityDataType::NORMAL);
            }
        }
        return $this;
    }
    
    /**
     * Sets a condition to hide the widget.
     *
     * Examples
     *
     * Hide an `Input` if a checkbox not checked:
     *
     * ```json
     *  "widget_type": "Input"
     *  "disabled_if": {
     *      "value_left": "=id_of_checkbox",
     *      "comparator": "!=",
     *      "value_right": "1"
     *  }
     *
     * ```
     * 
     * Hide an `Input` if is is empty:
     *
     * ```json
     *  "widget_type": "Input"
     *  "disabled_if": {
     *      "value_left": "=self",
     *      "comparator": "==",
     *      "value_right": ""
     *  }
     *
     * ```
     *
     * @uxon-property hidden_if
     * @uxon-type \exface\Core\Widgets\Parts\ConditionalProperty
     * @uxon-template {"operator": "AND", "conditions": [{"value_left": "", "comparator": "", "value_right": ""}]}
     *
     * @param UxonObject $value
     * @return \exface\Core\Widgets\AbstractWidget
     */
    public function setHiddenIf(UxonObject $uxon) : WidgetInterface
    {
        $this->hidden_if = $uxon;
        return $this;
    }
    
    /**
     *
     * @return ConditionalProperty|NULL
     */
    public function getHiddenIf() : ?ConditionalProperty
    {
        if ($this->hidden_if === null) {
            return null;
        }
        
        if (! ($this->hidden_if instanceof ConditionalProperty)) {
            $this->hidden_if = new ConditionalProperty($this, 'hidden_if', $this->hidden_if);
        }
        
        return $this->hidden_if;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getPrefillData()
     */
    public function getPrefillData()
    {
        return $this->prefill_data;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setPrefillData()
     */
    public function setPrefillData(DataSheetInterface $data_sheet)
    {
        $this->prefill_data = $data_sheet;
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::implementsInterface()
     */
    public function implementsInterface($interface_name)
    {
        $type_class = '\\exface\\Core\\Interfaces\\Widgets\\' . $interface_name;
        if ($this instanceof $type_class) {
            return true;
        } else {
            return false;
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::is()
     */
    public function is($type)
    {
        $type_class = '\\exface\\Core\\Widgets\\' . $type;
        if ($this instanceof $type_class) {
            return true;
        } else {
            return false;
        }
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::isExactly()
     */
    public function isExactly($widget_type)
    {
        $type_class = 'exface\\Core\\Widgets\\' . $widget_type;
        if (get_class($this) === $type_class) {
            return true;
        }
        return false;
    }

    /**
     * Forces the widget to use the specified data connection.
     * 
     * Use with care: if widgets on a single page use different connections for the same
     * object, the resulting data will be unpredictable and probably broken!
     * 
     * @uxon-property data_connection_alias
     * @uxon-type metamodel:connection
     *
     * @see \exface\Core\Interfaces\WidgetInterface::setDataConnectionAlias()
     */
    public function setDataConnectionAlias($value)
    {
        $this->data_connection_alias_specified_by_user = $value;
        $this->getMetaObject()->setDataConnectionAlias($value);
        return $this;
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WorkbenchDependantInterface::getWorkbench()
     */
    public function getWorkbench()
    {
        return $this->getPage()->getWorkbench();
    }

    /**
     *
     * {@inheritdoc}
     *
     * @see \exface\Core\Interfaces\WidgetInterface::getPage()
     */
    public function getPage()
    {
        return $this->page;
    }

    /**
     * Returns the translation string for the given message id.
     *
     * This is a shortcut for calling $this->getApp()->getTranslator()->translate().
     *
     * @see Translation::translate()
     *
     * @param string $message_id            
     * @param array $placeholders            
     * @param float $number_for_plurification            
     * @return string
     */
    public function translate($message_id, array $placeholders = null, $number_for_plurification = null)
    {
        $message_id = trim($message_id);
        return $this->getWorkbench()->getCoreApp()->getTranslator()->translate($message_id, $placeholders, $number_for_plurification);
    }

    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getDoNotPrefill()
     */
    public function getDoNotPrefill()
    {
        return $this->do_not_prefill;
    }

    /**
     * Set to TRUE to not prefill the widget with any action data.
     * 
     * @uxon-property do_not_prefill
     * @uxon-type boolean
     * @uxon-default false
     * 
     * @see \exface\Core\Interfaces\WidgetInterface::setDoNotPrefill()
     */
    public function setDoNotPrefill($value)
    {
        $this->do_not_prefill = BooleanDataType::cast($value);
        return $this;
    }

    /**
     * @deprecated use setDisabledIf() instead!
     * 
     * E.g.:
     * 
     * ```json
     *  "disable_condition": {
     *      "widget_link": "consumer!CONSUMER_MAIL_PHONE",
     *      "comparator": "!=",
     *      "value": ""
     *  }
     *  
     * ```
     * 
     * means the current widget is disabled when the column CONSUMER_MAIL_PHONE of
     * widget consumer is not empty. Can be usefully combined with a value-reference
     * to the same widget and column.
     *
     * @param UxonObject $value            
     * @return \exface\Core\Widgets\AbstractWidget
     */
    public function setDisableCondition($value)
    {
        return $this->setDisabledIf($value);
    }
    
    /**
     * Sets a condition to disable the widget.
     *
     * ## Examples
     * 
     * Disable an `Input` if checkbox not checked:
     *
     * ```json
     *  {
     *      "widget_type": "Input",
     *      "disabled_if": {
     *          "value_left": "=id_of_checkbox",
     *          "comparator": "!=",
     *          "value_right": "1"
     *      }
     *  }
     *
     * ```
     * 
     * Disable a `Button` if selected table row does not have required data:
     *
     * ```json
     *  {
     *      "widget_type": "Button",
     *      "caption": "Call",
     *      "disabled_if": {
     *          "value_left": "=id_of_table!PHONE_NUMBER",
     *          "comparator": "==",
     *          "value_right": ""
     *      }
     *  }
     *
     * ```
     * 
     * Disable a `Button` on a complex AND-condition
     * 
     * ```json
     *  {
     *      "widget_type": "Button",
     *      "caption": "Call",
     *      "disabled_if": {
     *          "operator": "AND",
     *          "conditions": [{
     *              "value_left": "=id_of_table!PHONE_NUMBER",
     *              "comparator": "==",
     *              "value_right": ""
     *          },{
     *              "value_left": "=id_of_table!ALLOW_PHONE_CALLS",
     *              "comparator": "==",
     *              "value_right": "1"
     *          }
     *      ]
     *  }
     *
     * ```
     *
     * @uxon-property disabled_if
     * @uxon-type \exface\Core\Widgets\Parts\ConditionalProperty
     * @uxon-template {"operator": "AND", "conditions": [{"value_left": "", "comparator": "", "value_right": ""}]}
     *
     * @param UxonObject $value
     * @return \exface\Core\Widgets\AbstractWidget
     */
    public function setDisabledIf(UxonObject $uxon) : WidgetInterface
    {
        $this->disabled_if = $uxon;
        return $this;
    }

    /**
     * 
     * @return ConditionalProperty|NULL
     */
    public function getDisabledIf() : ?ConditionalProperty
    {
        if ($this->disabled_if === null) {
            return null;
        }
        
        if (! ($this->disabled_if instanceof ConditionalProperty)) {
            $this->disabled_if = new ConditionalProperty($this, 'disabled_if', $this->disabled_if);
        }
        
        return $this->disabled_if;
    }
    
    /**
     * Returns the closest parent widget which implements the passed class or interface.
     * 
     * Returns null if no such parent widget exists.
     *
     * @param string $classOrInterface            
     * @return WidgetInterface|NULL
     */
    public function getParentByClass(string $classOrInterface) : ?WidgetInterface
    {
        if (! array_key_exists($classOrInterface, $this->parentByType)) {
            $widget = $this;
            while ($widget->getParent()) {
                $widget = $widget->getParent();
                
                // Ein Filter is eher ein Wrapper als ein Container (kann nur ein Widget enthalten).
                if (($classOrInterface == 'exface\\Core\\Interfaces\\Widgets\\iContainOtherWidgets') && ($widget instanceof $classOrInterface) && ($widget instanceof Filter)) {
                    continue;
                }
                
                if ($widget instanceof $classOrInterface) {
                    $this->parentByType[$classOrInterface] = $widget;
                    break;
                }
            }
            
            if (! array_key_exists($classOrInterface, $this->parentByType)) {
                $this->parentByType[$classOrInterface] = null;
            }
        }
        return $this->parentByType[$classOrInterface];
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\iCanBeCopied::copy()
     */
    public function copy() : self
    {
        return WidgetFactory::createFromUxon($this->getPage(), $this->exportUxonObject(), $this->getParent());
    }
    
    /**
     * This is a shortcut to calling $this->getWorkbench()->eventManager()->dispatch()
     * 
     * @param EventInterface $event
     * @return AbstractWidget
     */
    protected function dispatchEvent(EventInterface $event) : AbstractWidget
    {
        $this->getWorkbench()->eventManager()->dispatch($event);
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::getFacadeOptions()
     */
    public function getFacadeOptions(FacadeInterface $facade) : ?UxonObject
    {
        if ($this->facadeOptions === null) {
            return null;
        }
        foreach ($this->facadeOptions as $facadeSelectorString => $uxon) {
            $facadeSelector = SelectorFactory::createFacadeSelector($this->getWorkbench(), $facadeSelectorString);
            if ($facade->is($facadeSelector)) {
                return $uxon;
            }
        }
        return null;
    }
    
    /**
     * Facade-specific options for this widget defined for each facade
     * 
     * Example:
     * 
     * ```
     * {
     *  "facade_options": {
     *      "exface.AdminLTEFacade.AdminLTEFacade": {
     *          "option_1": "value_of_option_1",
     *          "option_2": "value_of_option_2"
     *      }
     *  }
     * }
     * 
     * ```
     * 
     * @uxon-property facade_options
     * @uxon-type object
     * @uxon-template {"": {"": ""}}
     * 
     * @param UxonObject $value
     * @return AbstractWidget
     */
    public function setFacadeOptions(UxonObject $value) : WidgetInterface
    {
        $this->facadeOptions = $value;
        return $this;
    }
    
    /**
     * 
     * {@inheritDoc}
     * @see \exface\Core\Interfaces\WidgetInterface::hasFacadeOptions()
     */
    public function hasFacadeOptions(FacadeInterface $facade) : bool
    {
        return $this->getFacadeOptions($facade) !== null;
    }
    
    /**
     * 
     * @param MetaObjectInterface $object
     * @return MetaRelationPathInterface|NULL
     */
    public function findRelationPathFromObject(MetaObjectInterface $object) : ?MetaRelationPathInterface
    {
        if ($object->is($this->getMetaObject())) {
            return RelationPathFactory::createForObject($object);
        }
        
        // If the action is based on the same object as the widget's parent, use the widget's
        // logic to find the relation to the parent. Otherwise try to find a relation to the
        // action's object and throw an error if this fails.
        if ($this->hasParent() && $object->is($this->getParent()->getMetaObject()) && $relPath = $this->getObjectRelationPathFromParent()) {
            return $relPath;
        }
        
        if ($relPath = $object->findRelationPath($this->getMetaObject())) {
            return $relPath;
        }
        
        return null;
    }
    
    /**
     * Inherits all properties of the given widget.
     * 
     * Specify the `page_alias` only to inherit the configuration of the root widget of the page
     * or add a `widget_id` to inherit from a specific widget. Use jsut a `widget_id` to inherit
     * from a widget on the same page.
     * 
     * **NOTE**: if the inherited widget is located on the same page and has a custom id (i.e.
     * has an `id` property in it's configuration), that id will not be inherited because widget
     * ids must be unique within a page! However, you can explicitly control this behavior via
     * `keep_widget_id`.
     * 
     * @uxon-property extend_widget
     * @uxon-type \exface\Core\Widgets\Parts\WidgetInheriter|string
     * @uxon-template {"page_alias": ""}
     * 
     * @param string|UxonObject $stringOrUxonWidgetLink
     * @return WidgetInterface
     */
    protected function setExtendWidget($stringOrUxonWidgetLink) : WidgetInterface
    {
        $this->extendedFrom = $stringOrUxonWidgetLink;
        return $this;
    }
    
    public function hasFunction(string $functionName) : bool
    {
        $constName = 'static::FUNCTION_' . strtoupper($functionName);
        return defined($constName);
    }
    
    /**
     * Overrides certian translation keys for this widget. 
     * 
     * This allows to customize translations if they do not really fit in a certain use case.
     * 
     * @uxon-property translations
     * @uxon-type object
     * @uxon-template {"// laguage - e.g. `en`": {"SOME.TRANSLATION.KEY.HERE": "Custom translation here"}}
     * 
     * @param UxonObject $langsAndKeys
     * @return AbstractWidget
     */
    protected function setTranslations(UxonObject $langsAndKeys) : AbstractWidget
    {
        $this->customTranslations = UxonObject::fromArray($langsAndKeys->toArray(CASE_UPPER));
        return $this;
    }
    
    /**
     * 
     * @param string $lang
     * @param string $message_id
     * @param array $placeholders
     * @param number $number_for_plurification
     * @return string|NULL
     */
    public function getTranslationCustomization(string $lang, string $message_id, array $placeholders = null, $number_for_plurification = null) : ?string
    {
        if ($this->customTranslations === null) {
            return null;
        }
        $dictUxon = $this->customTranslations->getProperty(mb_strtoupper($lang));
        if (null === $dictUxon) {
            return null;
        }
        if (! $dictUxon->hasProperty($message_id)) {
            return null;
        }
        $translator = new TranslationsArray($lang, $dictUxon->toArray());
        return $translator->translate($message_id, $placeholders, $number_for_plurification);
    }
    
    /**
     * Returns TRUE if the given UXON property was explicitly defined for this widget (in its UXON model)
     * 
     * @param string $uxonPropertyName
     * @return bool
     */
    protected function hasPropertyDefined(string $uxonPropertyName) : bool
    {
        return ! empty($this->uxon_original) && $this->exportUxonObjectOriginal()->hasProperty($uxonPropertyName);
    }
}