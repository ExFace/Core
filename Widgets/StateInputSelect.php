<?php
namespace exface\Core\Widgets;

use exface\Core\Exceptions\Widgets\WidgetConfigurationError;
use exface\Core\CommonLogic\Model\RelationPath;

/**
 * This is a special InputSelect widget for the state attribute of objects with the StateMachineBehavior.
 *
 * This select widget is automatically populated with states from the StateMachineBehavior of the object
 * of the attribute it represents. It will have an option for every state defined in the behavior. The
 * id of the state is the value of the select, while the text visible to the user will contain the state
 * name optionally prefixed with the id (depending on the show_state_ids property).
 *
 * The StateInputSelect has multi_select option enabled by default. However, you can set it to FALSE and
 * add custom state selections as explicit options. This is usefull for filtering. Let's say, you have
 * a task management system with a state machine for the tas object with the following states: 10, 20, 50, 90, 99.
 * Assuming, the states 10-50 represent an open task, you could create the following select widget, that
 * would have the options "open" and "closed" with specific state ids additionally to the individual states.
 * These custom options will be placed before the autogenerated ones.
 *
 * {
 * "widget_type": "StateInputSelect",
 * "multi_select": false,
 * "selectable_options": {
 * "10,20,50": "Open",
 * "90,99": "Closed"
 * }
 * }
 *
 * @author Thomas Walter
 *        
 */
class StateInputSelect extends InputSelect
{

    /** @var boolean $show_state_ids */
    private $show_state_ids = true;

    /**
     * Set to FALSE to not show state ids in the dropdown - just the state names.
     * TRUE by default.
     *
     * @uxon-property show_state_ids
     * @uxon-type boolean
     *
     * @param boolean $show_state_ids            
     * @return StateInputSelect
     */
    public function setShowStateIds($show_state_ids)
    {
        $this->show_state_ids = $show_state_ids;
        return $this;
    }

    public function getSelectableOptions()
    {
        // Check if the attribute is the state in the StateMachineBehavior of it's object
        /* @var $smb \exface\Core\Behaviors\StateMachineBehavior */
        $smb = $this->getAttribute()
            ->getObject()
            ->getBehaviors()
            ->getByAlias('exface.Core.Behaviors.StateMachineBehavior');
        if (! $smb || ! $this->getAttribute() || $this->getAttribute()->getAlias() != $smb->getStateAttributeAlias()) {
            $error_text = 'Cannot use the widget "' . $this->getWidgetType() . '" for attribute "' . $this->getAttributeAlias() . '" of object "' . $this->getMetaObject()->getAliasWithNamespace() . '": ';
            if (! $smb) {
                $error_text .= 'The object "' . $this->getAttribute()
                    ->getObject()
                    ->getAliasWithNamespace() . '" does not have the StateMachineBehavior!';
            } elseif (! $this->getAttribute()) {
                $error_text .= 'Attribute not found!';
            } else {
                $error_text .= 'The attribute is not the state attribute - use "' . RelationPath::relationPathAdd($this->getAttribute()
                    ->getRelationPath()
                    ->toString(), $smb->getStateAttributeAlias()) . '" instead!';
            }
            
            throw new WidgetConfigurationError($this, $error_text, '6UMTC14');
        }
        
        $options = $this->applyStateNames(parent::getSelectableOptions());
        if ($this->show_state_ids)
            return $this->addStateNumbers($options);
        else
            return $options;
    }

    protected function addStateNumbers($options)
    {
        $smb = $this->getAttribute()
            ->getObject()
            ->getBehaviors()
            ->getByAlias('exface.Core.Behaviors.StateMachineBehavior');
        if (! $smb)
            return parent::getSelectableOptions();
        
        $states = $smb->getStates();
        $appliedOptions = array();
        foreach ($options as $stateNum => $optionValue) {
            /** @var StateMachineState $stateObject */
            $stateObject = $states[$stateNum];
            if (! $stateObject) {
                $appliedOptions[$stateNum] = $optionValue;
                continue;
            }
            
            $appliedOptions[$stateNum] = $stateNum . ' ' . $optionValue;
        }
        return $appliedOptions;
    }

    /**
     * Uses possibly existing name and name_translation_key attributes of StateMachineStates for displaying options.
     *
     * @param
     *            $options
     * @return array
     */
    protected function applyStateNames($options)
    {
        if (! ($smb = $this->getAttribute()
            ->getObject()
            ->getBehaviors()
            ->getByAlias('exface.Core.Behaviors.StateMachineBehavior'))) {
            return $options;
        }
        
        $states = $smb->getStates();
        $appliedOptions = $options;
        
        foreach ($states as $stateNum => $stateObject) {
            if ($appliedOptions[$stateNum])
                continue;
            $name = $stateObject->getStateName($this->getAttribute()
                ->getObject()
                ->getApp()
                ->getTranslator());
            $appliedOptions[$stateNum] = $name;
        }
        
        return $appliedOptions;
    }
}
