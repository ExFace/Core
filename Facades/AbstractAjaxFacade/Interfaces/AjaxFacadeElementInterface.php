<?php
namespace exface\Core\Facades\AbstractAjaxFacade\Interfaces;

use exface\Core\Interfaces\Facades\HttpFacadeInterface;
use exface\Core\Interfaces\WidgetInterface;
use exface\Core\Interfaces\Facades\FacadeInterface;
use exface\Core\Interfaces\Actions\ActionInterface;

/**
 * 
 * @author Andrej Kabachnik
 *
 */
interface AjaxFacadeElementInterface 
{
    
    public function __construct(WidgetInterface $widget, FacadeInterface $facade);

    /**
     * Returns the complete JS code needed for the element
     */
    public function buildJs();

    /**
     * Returns the complete HTML code needed for the element
     */
    public function buildHtml();

    /**
     * Returns JavaScript headers, needed for the element as an array of lines.
     * Make sure, it is always an array, as it is quite possible, that multiple elements
     * require the same include and we will need to make sure, it is included only once.
     * The array provides an easy way to get rid of identical lines.
     *
     * Note, that the main includes for the core of jEasyUI generally need to be
     * placed in the facade of the CMS. This method ensures, that widgets can
     * add other includes like plugins, a plotting framework or other JS-resources.
     * Thus, the abstract widget returns an empty array.
     *
     * @return string[]
     */
    public function buildHtmlHeadTags();

    /**
     * Returns the widget, that this facade element represents
     *
     * @return WidgetInterface
     */
    public function getWidget();

    /**
     * Returns the facade engine
     *
     * @return HttpFacadeInterface
     */
    public function getFacade();

    /**
     * Returns a unique prefix for JavaScript functions to be used with this element
     *
     * @return string
     */
    public function buildJsFunctionPrefix();
    
    /**
     * Returns the CSS classes for this element (i.e. the contents of the HTML attribute class="...")
     * @return string
     */
    public function buildCssElementClass();
    
    /**
     * 
     * @param string $classes
     * @return AjaxFacadeElementInterface
     */
    public function addElementCssClass($string);
    
    /**
     * 
     * @param string $string
     * @return AjaxFacadeElementInterface
     */
    public function removeElementCssClass($string);
    
    /**
     * Returns css properties for this element: custom colors, styles, etc. - things that come into the style="...".
     *
     * @return string
     */
    public function buildCssElementStyle();
    
    /**
     *
     * @param string $css_properties
     * @return AjaxFacadeElementInterface
     */
    public function addElementCssStyle($css_properties);

    /**
     * Returns the id of the HTML-element representing the widget.
     * Passing a widget id makes the method return the id of the element
     * that belongs to that widget.
     *
     * @return string
     */
    public function getId();

    /**
     * Returns an inline-embedable JS snippet to get the current value of the widget: e.g.
     * $('#id').val() for simple inputs.
     * This snippet can be used to build interaction scripts between widgets.
     * NOTE: the result does not end with a semicolon!
     *
     * TODO add row and column to select a single value from the widgets data, which is generally represented by a DataSheet
     *
     * @return string
     */
    public function buildJsValueGetter();

    /**
     * Returns inline JS to set the current value of the widget: e.g.  $('#id').val(value).
     * 
     * This snippet can be used to build interaction scripts between widgets. It MUST trigger
     * a change event on it's widget - this way, chains of changes can be built: e.g. a
     * slave-table filter changes with the selection in a master-table and the slave-table
     * refreshes with changes of it's filter.
     *
     * The value can either be anything JS accepts as an argument: a scalar value, a variable, 
     * a funciton call (e.g. generated by build_js_value_getter()) or an anonymous function. 
     * 
     * NOTE: the value setter must be callable inline! In particular, there should not be a semicolon at the end!
     *
     * @param string $value            
     * @return string
     */
    public function buildJsValueSetter($value);

    /**
     * Returns a JS snippet, that refreshes the contents of this element
     *
     * @return string
     */
    public function buildJsRefresh();

    /**
     * Returns the width of the element in CSS notation (e.g.
     * 100px)
     *
     * @return string
     */
    public function getWidth();

    /**
     * Returns the height of the element in CSS notation (e.g.
     * 100px)
     *
     * @return string
     */
    public function getHeight();

    /**
     * Returns the default relative width of this element
     *
     * @return string
     */
    public function getWidthDefault();

    /**
     * Returns the width of one relative width unit in pixels
     *
     * @return string
     */
    public function getWidthRelativeUnit();

    /**
     * Returns the minimum width of one relative width unit in pixels
     *
     * @return string
     */
    public function getWidthMinimum();

    /**
     * Returns the height of one relative height unit in pixels
     *
     * @return string
     */
    public function getHeightRelativeUnit();

    /**
     * Returns an inline-embeddable JS snippet, that produces a JS-object ready to be encoded and sent to the server to
     * perform the given action: E.g.
     * {"oId": "UID of the meta object", "rows": [ {"col": "value, "col": "value, ...}, {...}, ... ] }.
     * Each element can decide itself, which data it should return for which type of action. If no action is given, the entire data
     * set used in the element should be returned.
     *
     * In contrast to build_js_value_getter(), which returns a value without context, the data getters return JS-representations of
     * data sheets - thus, the data is alwas bound to a meta object.
     *
     * @param ActionInterface $action            
     * @return string
     */
    public function buildJsDataGetter(ActionInterface $action = null);
    
    /**
     * Returns a JS snippet, that can set data given in the same structure as the data getter would produce.
     * 
     * This is basically the opposite of buildJsDataGetter(). The input must be valid JS code representing 
     * or returning a JS data sheet.
     * 
     * For example, this code will extract data from a table and put it into a container:
     * $container->buildJsDataSetter($table->buildJsDataGetter())
     * 
     * @param string $jsData
     * @return string
     */
    public function buildJsDataSetter(string $jsData) : string;
    
    /**
     * Adds a JavaScript snippet to the script, that will get executed every time the value of this element changes.
     * 
     * NOTE: the event object is available via the javascript variable "event".
     *
     * @param string $string            
     * @return AjaxFacadeElementInterface
     */
    public function addOnChangeScript($string);

    /**
     * Adds a JavaScript snippet to the script, that will get executed every time the size of this element changes
     *
     * @param string $js            
     * @return AjaxFacadeElementInterface
     */
    public function addOnResizeScript($js);
    
    /**
     * Adds a JavaScript snippet to the script, that will get executed every time the data of this element refreshes.
     *
     * @param string $string
     * @return \exface\Core\Facades\AbstractAjaxFacade\Elements\AbstractJqueryElement
     */
    public function addOnRefreshScript(string $js) : AjaxFacadeElementInterface;

    /**
     * Returns an JS-snippet to show a busy symbol (e.g.
     * hourglass, spinner). This centralized method is used in various traits.
     * @retrun string
     */
    public function buildJsBusyIconShow();

    /**
     * Returns an JS-snippet to hide the busy symbol (e.g.
     * hourglass, spinner). This centralized method is used in various traits.
     * @retrun string
     */
    public function buildJsBusyIconHide();

    /**
     * Returns a JS snippet showing an error message.
     * Body and title may be any JavaScript or quoted text (quotes will not be
     * added automatically!!!).
     *
     * @param string $message_body_js            
     * @param string $title_js            
     * @return string
     */
    public function buildJsShowMessageError($message_body_js, $title_js = null);

    /**
     * Returns a JS snippet showing a success notification.
     * The body of the message may be any JavaScript or quoted text (quotes will not be
     * added automatically!!!).
     *
     * @param string $message_body_js            
     * @param string $title            
     * @return string
     */
    public function buildJsShowMessageSuccess($message_body_js, $title = null);

    /**
     * Returns a JS snippet showing a server error.
     * Body and title may be any JavaScript or quoted text (quotes will not be
     * added automatically!!!).
     *
     * @param string $message_body_js            
     * @param string $title_js            
     * @return string
     */
    public function buildJsShowError($message_body_js, $title_js = null);

    /**
     * Returns an inline JS snippet which validates the widget.
     * Returns true if the widget is
     * valid, returns false if the widget is invalid.
     *
     * @param string|NULL $valJs
     * @return string
     */
    public function buildJsValidator(?string $valJs = null) : string;

    /**
     * Returns a JavaScript snippet which handles the situation where the widget is invalid e.g.
     * by overwriting this function the widget could be highlighted or an error message could be
     * shown.
     *
     * @return string
     */
    public function buildJsValidationError();

    /**
     * Returns an JS code to disable/enable the widget (with tailing semicolon!).
     * 
     * @param bool $trueOrFalse
     * @return string
     */
    public function buildJsSetDisabled(bool $trueOrFalse) : string;
    
    /**
     * Returns a JS snippet to destroy this element: i.e. remove from dom, unregister listeners, etc.
     * 
     * Call this method when a dialog gets closed or similar occasions to ensure no garbage remains.
     * 
     * Override this method to add cleanup-logic to your control - e.g. if you need to remove some
     * dom-elements, etc.
     * 
     * Make your container elements automatically destroy their children when the container gets destroyed.
     * The JqueryContainerTrait does this automatically.
     * 
     * @return string
     */
    public function buildJsDestroy() : string;
    
    /**
     * Returns a JS snippet to reset the widget to it's original state.
     * 
     * E.g. an `Input` should get it's default value back, a `Form` (or container in general) shoud reset 
     * all it's children, a data widget should get reset to it's original sorting/filtering configuration
     * (tha same should happen if it's configurator is reset).
     * 
     * @return string
     */
    public function buildJsResetter() : string;
    
    /**
     * Returns the JS code to call the specified widget function
     * 
     * @param string $functionName
     * @return string
     */
    public function buildJsCallFunction(string $functionName = null, array $parameters = []) : string;
    
}